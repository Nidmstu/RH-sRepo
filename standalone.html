<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Onboarding for Prompt Engineers</title>
  <link type="image/png" sizes="16x16" rel="icon" href="https://i.postimg.cc/gJf9MgWR/icons8-32.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">

  <!-- Стили из файла css/style.css -->
  <style>
    /* Основные настройки сайта */
    :root {
      --primary-color: #4a6baf;
      --primary-hover: #3a5b9f;
      --secondary-color: #6c757d;
      --success-color: #28a745;
      --danger-color: #dc3545;
      --light-color: #f8f9fa;
      --dark-color: #343a40;
      --background-color: #f5f7fa;
      --card-bg: #ffffff;
      --border-radius: 8px;
      --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --font-family: 'Roboto', -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
    }

    body {
      font-family: var(--font-family);
      background-color: var(--background-color);
      color: #333;
      line-height: 1.6;
      margin: 0;
      padding: 0;
      transition: all 0.3s ease;
    }

    header {
      background: var(--primary-color);
      color: white;
      padding: 1rem;
      text-align: center;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    /* Стили для карточек */
    .course-card {
      background-color: var(--card-bg);
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      padding: 20px;
      margin-bottom: 20px;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      cursor: pointer;
      border-left: 4px solid var(--primary-color);
    }

    .course-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
    }

    .course-card h3 {
      color: var(--primary-color);
      margin-top: 0;
      font-size: 1.4rem;
    }

    .course-card p {
      color: var(--secondary-color);
      margin-bottom: 10px;
    }

    /* Стили для кнопок */
    button {
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      transition: background-color 0.3s ease, transform 0.2s ease;
      margin: 5px 0;
      display: block;
      width: 100%;
      text-align: left;
    }

    button:hover {
      background-color: var(--primary-hover);
      transform: translateY(-2px);
    }

    /* Стили для разделов */
    .section {
      padding: 20px;
      background-color: var(--card-bg);
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      margin-bottom: 20px;
    }

    .section h2 {
      color: var(--primary-color);
      border-bottom: 2px solid var(--primary-color);
      padding-bottom: 10px;
      margin-top: 0;
    }

    /* Навигация */
    .navigation {
      display: flex;
      justify-content: space-between;
      margin-bottom: 20px;
    }

    .back-button {
      background-color: var(--secondary-color);
      max-width: 150px;
    }

    .back-button:hover {
      background-color: #5a6268;
    }

    /* Стили для списка дней */
    .content-cards {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 20px;
    }

    /* Стили для контейнера выбора уроков */
    #task-buttons {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    /* Markdown контент */
    #markdown-content {
      background-color: var(--card-bg);
      padding: 25px;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      line-height: 1.8;
    }

    #markdown-content h1, 
    #markdown-content h2,
    #markdown-content h3 {
      color: var(--primary-color);
    }

    #markdown-content h1 {
      border-bottom: 2px solid var(--primary-color);
      padding-bottom: 10px;
      margin-top: 0;
    }

    #markdown-content blockquote {
      border-left: 4px solid var(--primary-color);
      padding-left: 15px;
      color: var(--secondary-color);
      font-style: italic;
    }

    #markdown-content code {
      background-color: #f5f5f5;
      padding: 2px 4px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
    }

    #markdown-content pre code {
      display: block;
      padding: 15px;
      overflow-x: auto;
      background-color: #f8f9fa;
      border-radius: var(--border-radius);
    }

    /* Адаптивность для мобильных устройств */
    @media (max-width: 768px) {
      .content-cards {
        grid-template-columns: 1fr;
      }

      button {
        padding: 12px 15px;
      }

      #markdown-content {
        padding: 15px;
      }
    }

    /* Стили для загрузчика */
    .loading-container {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      padding: 30px;
    }

    .loading-spinner {
      border: 5px solid rgba(0, 0, 0, 0.1);
      border-top: 5px solid var(--primary-color);
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .loading-status {
      margin-top: 15px;
      font-size: 14px;
      color: var(--secondary-color);
    }

    /* Анимации появления */
    .fade-in {
      animation: fadeIn 0.5s ease-in;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    /* Стили для глобального индикатора загрузки */
    #global-loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.9);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 9999;
    }

    /* Улучшенная кнопка теста */
    #test-button {
      background-color: var(--success-color);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin: 20px auto;
      width: auto;
      max-width: 200px;
    }

    #test-button:hover {
      background-color: #218838;
    }

    /* Эффект затемнения для неактивных элементов */
    .hidden {
      display: none !important;
    }

    /* Поправка для выпадающего списка */
    select {
      padding: 10px;
      border-radius: var(--border-radius);
      border: 1px solid #ced4da;
      background-color: white;
      font-size: 16px;
      margin-bottom: 15px;
      width: 100%;
    }

    /* Added styles for collapsible blocks */
    details > summary {
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      padding: 10px 0;
      outline: none;
      transition: color 0.2s;
    }
    details details > summary {
      font-size: 0.9em;
      font-weight: bold;
      margin-left: 5px;
    }
    details details details > summary {
      font-size: 0.8em;
      font-weight: bold;
      margin-left: 10px;
    }
    details {
      background: #fff;
      margin: 10px 0;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    details[open] > summary {
      margin-bottom: 10px;
      color: #3498db;
    }
  </style>
</head>
  <body>
    <!-- Глобальный индикатор загрузки -->
    <div id="global-loading-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255, 255, 255, 0.9); z-index: 10000; display: flex; flex-direction: column; justify-content: center; align-items: center;">
      <div class="spinner" style="width: 80px; height: 80px; border-width: 8px;"></div>
      <h2 style="color: #3498db; margin-top: 20px;">Ожидание загрузки данных...</h2>
      <p id="global-loading-status" style="font-size: 16px; margin-top: 15px;">Проверка источников данных...</p>
    </div>

    <!-- Индикатор загрузки -->
    <div id="loading-spinner" class="container center" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #f8f8f8; z-index: 9999; display: flex; flex-direction: column; justify-content: center; align-items: center;">
      <div class="spinner" style="width: 80px; height: 80px; border-width: 8px;"></div>
      <h2 style="color: #3498db; margin-top: 20px;">Загрузка данных курсов...</h2>
      <p class="loading-status" style="font-size: 16px; margin-top: 15px;">Инициализация...</p>
      <div id="loading-retry-container" class="hidden" style="margin-top: 20px; background-color: #ffeeee; padding: 15px; border-radius: 5px; border-left: 4px solid #ff5555;">
        <p style="font-weight: bold; color: #cc0000;">Не удалось загрузить данные. Возможно, проблемы с подключением.</p>
        <button onclick="location.reload()" style="background-color: #ff5555; margin-top: 10px;">Повторить загрузку</button>
        <p style="font-size: 14px; margin-top: 10px; color: #666;">Если проблема повторяется, обратитесь к администратору.</p>
      </div>
    </div>

    <!-- Основной контент приложения -->
    <div id="app-content" class="hidden">
      <!-- Домашняя страница -->
      <div id="home" class="container center">
        <div id="day-selection">
          <h1>Learning Platform</h1>
          <p>
            Course:&nbsp;
            <select id="profession-select" onchange="handleProfessionChange()">
              <option value="">Select a course</option>
            </select>
          </p>

          <div style="margin: 30px 0;">
            <p>Quick Reference:</p>
            <div id="vocabulary-container">
              <!-- Vocabulary buttons will be dynamically added here -->
            </div>
          </div>

          <div style="margin-top: 30px;">
            <p>Select Training Day:</p>
            <div id="days-container">
              <!-- Day buttons will be dynamically added here -->
            </div>
          </div>

          <div id="admin-access" style="margin-top: 30px;">
            <a href="admin.html" style="text-decoration: none;">
              <button style="background-color: #3498db;">Course Management</button>
            </a>
          </div>
        </div>
        <div id="task-selection" class="hidden">
          <h1 id="day-header"></h1>
          <div id="task-buttons" class="task-buttons"></div>
          <button onclick="goBackToDaySelection()">Back</button>
        </div>
      </div>

      <!-- Страница гайда -->
      <div id="guide" class="container hidden">
        <h1 id="guide-title">Guide:</h1>
        <div id="content-loading-spinner" class="center hidden">
          <div class="spinner"></div>
          <p>Загрузка содержимого...</p>
        </div>

        <!-- Универсальный аудио-контейнер для всех типов аудио -->
        <div id="audio-embed" class="hidden center audio-container" style="margin-bottom: 20px; max-width: 100%; width: 100%; display: flex; flex-direction: column; align-items: center;">
          <!-- Динамически заполняется из JS -->
        </div>

        <!-- Скрытые аудио-контейнеры для обратной совместимости -->
        <div id="audio-first-lesson" class="hidden"></div>
        <div id="audio-vocabulary" class="hidden"></div>

        <!-- Резервный аудио-контейнер для прямых URL -->
        <div id="audio-fallback" class="hidden center audio-container" style="margin-bottom: 20px; max-width: 100%; width: 100%;">
          <audio controls style="width:100%; max-width:600px;">
            <source src="" type="audio/mpeg" id="audio-fallback-source">
            Ваш браузер не поддерживает аудио элемент.
          </audio>
        </div>

        <!-- Контейнер для Markdown контента -->
        <div id="markdown-content" class="markdown-content hidden"></div>

        <!-- Кнопка Test для выбранного модуля -->
        <div class="center" style="margin-top:20px;">
          <button id="test-button" onclick="window.location.href = currentTopic.testWebhook">Test</button>
        </div>
        <!-- Кнопка Back для возврата к списку топиков -->
        <div class="center" style="margin-top:20px;">
          <button onclick="goBackToTaskSelection()">Back</button>
        </div>
      </div>
    </div>

    <!-- Дополнительные встроенные стили для индикатора загрузки -->
    <style>
      /* Улучшенные стили для индикатора загрузки */
      #loading-spinner .spinner {
        border: 8px solid #f3f3f3;
        border-top: 8px solid #3498db;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        animation: spin 1.5s linear infinite;
        margin: 0 auto 20px auto;
      }

      #loading-spinner p {
        margin: 10px 0;
        font-size: 18px;
        color: #333;
      }

      .loading-status {
        font-size: 14px !important;
        color: #666 !important;
        margin-top: 5px;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
    </style>
  </body>
  <script>
  // ==================== BEGIN COURSE MANAGER CODE ====================
  /**
   * Course Manager Module
   * Отвечает за загрузку и управление всеми данными курсов
   */
  class CourseManager {
    constructor() {
      this.courses = null;
      this.fallbacks = null;
      this.currentProfession = "prompt-engineer";
      this.currentDay = null;
      this.currentLesson = null;
    }

    /**
     * Инициализирует менеджер курсов
     */
    async initialize() {
      try {
        console.log('CourseManager: Начало инициализации...');
        console.log('CourseManager: Текущее время:', new Date().toISOString());

        // Подписчики на изменение курсов
        this.courseUpdateCallbacks = [];

        // Выводим текущее состояние и проверяем наличие данных
        console.log('CourseManager: Текущее состояние courses:', this.courses ? Object.keys(this.courses) : 'null');

        // Проверяем, есть ли уже загруженные данные из предыдущей синхронизации
        if (this.courses && Object.keys(this.courses).length > 0) {
          console.log('CourseManager: Данные уже загружены из синхронизации, продолжаем с ними');
          console.log('CourseManager: Количество загруженных профессий:', Object.keys(this.courses).length);
          console.log('CourseManager: Идентификаторы профессий:', Object.keys(this.courses).join(', '));

          // Дополнительная проверка данных - наличие дней и уроков для каждой профессии
          let dataIsValid = true;
          for (const profId of Object.keys(this.courses)) {
            const course = this.courses[profId];

            // Если это редирект, то дни не нужны
            if (course.redirectUrl) {
              console.log(`CourseManager: Профессия ${profId} имеет редирект, структура валидна`);
              continue;
            }

            // Проверяем наличие дней для этой профессии
            if (!course.days || !Array.isArray(course.days) || course.days.length === 0) {
              console.warn(`CourseManager: Профессия ${profId} не имеет дней обучения!`);
              dataIsValid = false;
            } else {
              // Проверяем наличие уроков для каждого дня
              course.days.forEach((day, idx) => {
                if (!day.lessons || !Array.isArray(day.lessons) || day.lessons.length === 0) {
                  console.warn(`CourseManager: День ${idx + 1} профессии ${profId} не имеет уроков!`);
                  dataIsValid = false;
                } else {
                  // Проверяем наличие contentSource для первого урока
                  const firstLesson = day.lessons[0];
                  if (!firstLesson.contentSource) {
                    console.warn(`CourseManager: Первый урок в дне ${idx + 1} профессии ${profId} не имеет contentSource!`);
                    dataIsValid = false;
                  }
                }
              });
            }
          }

          if (dataIsValid) {
            console.log('CourseManager: Проверка структуры данных успешна, данные валидны');
            // Уведомляем об имеющихся курсах
            this.notifyCoursesUpdated();
            return true;
          } else {
            console.warn('CourseManager: Структура данных некорректна, требуется повторная загрузка');
            // Продолжаем загрузку для обновления данных
          }
        }

        console.log('CourseManager: Данные не найдены, начинаю загрузку...');

        // Получаем настройки вебхуков из localStorage
        let importWebhookUrl = null;
        const adminWebhookUrl = localStorage.getItem('adminImportWebhook');
        if (adminWebhookUrl) {
          importWebhookUrl = adminWebhookUrl;
          console.log(`CourseManager: Используется URL из adminImportWebhook: ${importWebhookUrl}`);
        } else {
          const webhookSettingsStr = localStorage.getItem('webhookSettings');
          if (webhookSettingsStr) {
            try {
              const webhookSettings = JSON.parse(webhookSettingsStr);
              if (webhookSettings.importUrl) {
                importWebhookUrl = webhookSettings.importUrl;
                console.log(`CourseManager: Используется URL из webhookSettings: ${importWebhookUrl}`);
              }
            } catch (e) {
              console.error('Ошибка при парсинге настроек вебхуков:', e);
            }
          }
        }
        if (!importWebhookUrl) {
          importWebhookUrl = localStorage.getItem('importWebhookUrl');
          if (importWebhookUrl) {
            console.log(`CourseManager: Используется URL из importWebhookUrl: ${importWebhookUrl}`);
          }
        }
        if (!importWebhookUrl) {
          importWebhookUrl = localStorage.getItem('testImportUrl');
          if (importWebhookUrl) {
            console.log(`CourseManager: Используется URL из testImportUrl: ${importWebhookUrl}`);
          }
        }

        if (window.devMode && window.devMode.enabled) {
          console.log('🔧 [DevMode] Начало инициализации CourseManager');
          if (importWebhookUrl) {
            console.log(`🔧 [DevMode] Будет использован вебхук для импорта: ${importWebhookUrl}`);
          } else {
            console.log('🔧 [DevMode] URL вебхука для импорта не найден, будет использован локальный файл');
          }
        }

        // Загрузка данных с вебхука
        try {
          let webhookUrl = importWebhookUrl;
          if (!webhookUrl) {
            const webhookSettings = localStorage.getItem('webhookSettings');
            const adminWebhookUrl = localStorage.getItem('adminImportWebhook');
            const testImportUrl = localStorage.getItem('testImportUrl');
            if (adminWebhookUrl) {
              webhookUrl = adminWebhookUrl;
              console.log(`Найден URL импорта в adminImportWebhook: ${webhookUrl}`);
            } else if (webhookSettings) {
              try {
                const settings = JSON.parse(webhookSettings);
                if (settings.importUrl) {
                  webhookUrl = settings.importUrl;
                  console.log(`Найден URL импорта в настройках вебхуков: ${webhookUrl}`);
                  localStorage.setItem('importWebhookUrl', webhookUrl);
                }
              } catch (e) {
                console.error('Ошибка при парсинге настроек вебхуков:', e);
              }
            } else if (testImportUrl) {
              webhookUrl = testImportUrl;
              console.log(`Найден URL импорта в testImportUrl: ${webhookUrl}`);
            }
          }

          console.log('Попытка загрузки данных с URL:', webhookUrl);

          if (webhookUrl) {
            if (window.devMode && window.devMode.enabled) {
              console.log(`🔧 [DevMode] Отправка запроса на вебхук импорта: ${webhookUrl}`);
            }

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000);

            try {
              const importResponse = await fetch(webhookUrl, {
                method: 'GET',
                headers: {
                  'Accept': 'application/json, text/plain, */*',
                  'Content-Type': 'application/json'
                },
                cache: 'no-store',
                signal: controller.signal
              });

              clearTimeout(timeoutId);

              if (importResponse.ok) {
                let importData;
                const responseText = await importResponse.text();
                console.log('Получен ответ от вебхука, размер:', responseText.length, 'байт');

                try {
                  importData = JSON.parse(responseText);
                  if (window.devMode && window.devMode.enabled) {
                    console.log('🔧 [DevMode] Успешно получены данные с вебхука импорта');
                    console.log('🔧 [DevMode] Размер полученных данных:', responseText.length, 'байт');
                  }
                } catch (jsonError) {
                  if (window.devMode && window.devMode.enabled) {
                    console.log(`🔧 [DevMode] Ошибка при парсинге JSON: ${jsonError.message}`);
                    console.log('🔧 [DevMode] Попытка найти JSON в тексте ответа');
                  }
                  try {
                    const jsonRegex = /{[\s\S]*}/;
                    const match = responseText.match(jsonRegex);
                    if (match && match[0]) {
                      importData = JSON.parse(match[0]);
                      if (window.devMode && window.devMode.enabled) {
                        console.log('🔧 [DevMode] Найден и распарсен JSON в тексте ответа');
                      }
                    }
                  } catch (extractError) {
                    if (window.devMode && window.devMode.enabled) {
                      console.log(`🔧 [DevMode] Не удалось извлечь JSON из текста: ${extractError.message}`);
                    }
                    throw new Error('Не удалось распарсить JSON из ответа');
                  }
                }

                let coursesData = null;
                if (importData) {
                  if (window.devMode && window.devMode.enabled) {
                    console.log(`🔧 [DevMode] Анализ полученных данных:`, Object.keys(importData));
                  }
                  if (importData.courses) {
                    coursesData = importData.courses;
                    if (window.devMode && window.devMode.enabled) {
                      console.log(`🔧 [DevMode] Найдены курсы в поле 'courses'`);
                    }
                  } else if (importData.data && typeof importData.data === 'object') {
                    coursesData = importData.data;
                    if (window.devMode && window.devMode.enabled) {
                      console.log(`🔧 [DevMode] Найдены курсы в поле 'data' (объект)`);
                    }
                  } else if (importData.content && typeof importData.content === 'object') {
                    coursesData = importData.content;
                    if (window.devMode && window.devMode.enabled) {
                      console.log(`🔧 [DevMode] Найдены курсы в поле 'content' (объект)`);
                    }
                  } else if (importData.data && typeof importData.data === 'string') {
                    try {
                      const parsedData = JSON.parse(importData.data);
                      if (parsedData.courses) {
                        coursesData = parsedData.courses;
                        if (window.devMode && window.devMode.enabled) {
                          console.log(`🔧 [DevMode] Найдены курсы в поле 'data' (JSON строка -> courses)`);
                        }
                      } else {
                        coursesData = parsedData;
                        if (window.devMode && window.devMode.enabled) {
                          console.log(`🔧 [DevMode] Найдены курсы в поле 'data' (JSON строка -> весь объект)`);
                        }
                      }
                    } catch (e) {
                      if (window.devMode && window.devMode.enabled) {
                        console.log(`🔧 [DevMode] Ошибка при парсинге строки data: ${e.message}`);
                      }
                    }
                  } else if (typeof importData === 'object') {
                    const hasValidStructure = Object.values(importData).some(value => {
                      return value && typeof value === 'object' && 
                            (value.days || value.specialLessons || value.title || value.redirectUrl || value.noDayLessons);
                    });
                    if (hasValidStructure) {
                      coursesData = importData;
                      if (window.devMode && window.devMode.enabled) {
                        console.log(`🔧 [DevMode] Использование корневого объекта как courses (найдены поля days/specialLessons/title)`);
                      }
                    }
                  }
                }

                if (coursesData) {
                  const courseKeys = Object.keys(coursesData);
                  const validStructure = courseKeys.length > 0 && 
                    courseKeys.some(key => {
                      const course = coursesData[key];
                      return course && typeof course === 'object' && 
                            (course.days || course.specialLessons || course.redirectUrl);
                    });
                  if (!validStructure) {
                    if (window.devMode && window.devMode.enabled) {
                      console.log(`🔧 [DevMode] Полученная структура данных не соответствует формату курсов`, coursesData);
                    }
                    throw new Error('Формат данных не соответствует структуре курсов');
                  }
                  this.courses = coursesData;
                  console.log('Курсы успешно загружены с вебхука импорта');
                  console.log('Загружены следующие профессии:', Object.keys(this.courses));
                  Object.keys(this.courses).forEach(profId => {
                    const course = this.courses[profId];
                    console.log(`Профессия ${profId}: ${course.title || 'Без названия'}`);
                    if (course.days) {
                      console.log(`- Дней обучения: ${course.days.length}`);
                      course.days.forEach(day => {
                        console.log(`  - День ${day.id}: ${day.title} (${day.lessons ? day.lessons.length : 0} уроков)`);
                      });
                    }
                    if (course.specialLessons) {
                      console.log(`- Специальных уроков: ${course.specialLessons.length}`);
                    }
                  });
                  localStorage.setItem('coursesBackup', JSON.stringify(this.courses));
                  localStorage.setItem('coursesBackupTimestamp', new Date().toISOString());
                  console.log('Резервная копия сохранена в localStorage, метка времени:', new Date().toISOString());
                  if (window.devMode && window.devMode.enabled) {
                    console.log('🔧 [DevMode] Сохранена резервная копия курсов в localStorage');
                    console.log('🔧 [DevMode] Идентификаторы загруженных курсов:', Object.keys(this.courses));
                  }
                  this.notifyCoursesUpdated();
                  return true;
                } else {
                  throw new Error('Полученные данные не содержат информацию о курсах');
                }
              } else {
                throw new Error(`Ошибка запроса к вебхуку импорта: ${importResponse.status}`);
              }
            } catch (fetchError) {
              clearTimeout(timeoutId);
              if (fetchError.name === 'AbortError') {
                throw new Error('Таймаут запроса к вебхуку импорта');
              } else {
                throw fetchError;
              }
            }
          } else {
            throw new Error('URL вебхука для импорта не найден');
          }
        } catch (importError) {
          console.error('Ошибка при загрузке данных с вебхука импорта:', importError);
          if (window.devMode && window.devMode.enabled) {
            console.log(`🔧 [DevMode] Ошибка при загрузке с вебхука: ${importError.message}`);
            console.log('🔧 [DevMode] Переключение на загрузку из localStorage');
          }
          const backupStr = localStorage.getItem('coursesBackup');
          if (backupStr) {
            try {
              this.courses = JSON.parse(backupStr);
              const timestamp = localStorage.getItem('coursesBackupTimestamp') || 'неизвестно';
              console.log(`Курсы восстановлены из резервной копии (${timestamp})`);
              if (window.devMode && window.devMode.enabled) {
                console.log(`🔧 [DevMode] Загружена резервная копия курсов из localStorage от ${timestamp}`);
              }
              return true;
            } catch (backupError) {
              console.error('Ошибка при восстановлении из резервной копии:', backupError);
              if (window.devMode && window.devMode.enabled) {
                console.log(`🔧 [DevMode] Переключение на загрузку из локального файла`);
              }
            }
          } else {
            if (window.devMode && window.devMode.enabled) {
              console.log('🔧 [DevMode] Резервная копия не найдена, переключение на локальный файл');
            }
          }
          try {
            if (window.devMode && window.devMode.enabled) {
              console.log('🔧 [DevMode] Загрузка курсов из локального файла courses.json');
            }
            const coursesResponse = await fetch('data/courses.json');
            if (coursesResponse.ok) {
              this.courses = await coursesResponse.json();
              console.log('Курсы загружены из локального файла courses.json (резервный вариант)');
              localStorage.setItem('coursesBackup', JSON.stringify(this.courses));
              localStorage.setItem('coursesBackupTimestamp', new Date().toISOString());
              if (window.devMode && window.devMode.enabled) {
                console.log('🔧 [DevMode] Сохранена резервная копия курсов из локального файла');
              }
            } else {
              throw new Error(`Не удалось загрузить структуру курсов из локального файла: ${coursesResponse.status}`);
            }
          } catch (coursesError) {
            console.error('Ошибка при загрузке локального файла courses.json:', coursesError);
            this.courses = {};
            return false;
          }
        }

        // Загрузка резервного контента
        try {
          const fallbacksResponse = await fetch('data/fallbacks.json');
          if (fallbacksResponse.ok) {
            this.fallbacks = await fallbacksResponse.json();
            localStorage.setItem('fallbacksBackup', JSON.stringify(this.fallbacks));
            localStorage.setItem('fallbacksBackupTimestamp', new Date().toISOString());
          } else {
            throw new Error(`Не удалось загрузить резервный контент: ${fallbacksResponse.status}`);
          }
        } catch (fallbacksError) {
          console.warn('Ошибка при загрузке fallbacks.json:', fallbacksError);
          const backupStr = localStorage.getItem('fallbacksBackup');
          if (backupStr) {
            try {
              this.fallbacks = JSON.parse(backupStr);
              const timestamp = localStorage.getItem('fallbacksBackupTimestamp') || 'неизвестно';
              console.log(`Резервный контент восстановлен из копии (${timestamp})`);
            } catch (backupError) {
              console.error('Ошибка при восстановлении резервного контента:', backupError);
              this.fallbacks = {};
            }
          } else {
            console.warn('Резервная копия fallbacks не найдена, используется пустой объект');
            this.fallbacks = {};
          }
        }

        console.log('CourseManager инициализирован успешно');
        return true;
      } catch (error) {
        console.error('Ошибка при инициализации CourseManager:', error);
        return false;
      }
    }

    getProfessions(includeHidden = false) {
      if (!this.courses || typeof this.courses !== 'object') {
        console.error('Объект courses не определен или не является объектом:', this.courses);
        return [];
      }
      if (includeHidden) {
        return Object.keys(this.courses);
      } else {
        const visibleCourses = Object.keys(this.courses).filter(profId => {
          const course = this.courses[profId];
          const isHidden = course.hidden === true;
          console.log(`Проверка видимости курса ${profId}: hidden=${course.hidden}, isHidden=${isHidden}`);
          return !isHidden;
        });
        console.log('Видимые курсы:', visibleCourses);
        return visibleCourses;
      }
    }

    switchProfession(professionId) {
      if (this.courses[professionId]) {
        this.currentProfession = professionId;
        this.currentDay = null;
        this.currentLesson = null;
        return true;
      }
      return false;
    }

    hasRedirect(professionId = this.currentProfession) {
      return this.courses[professionId]?.redirectUrl !== undefined;
    }

    getRedirectUrl(professionId = this.currentProfession) {
      return this.courses[professionId]?.redirectUrl;
    }

    getDays() {
      if (!this.courses[this.currentProfession] || !this.courses[this.currentProfession].days) {
        return [];
      }
      return this.courses[this.currentProfession].days;
    }

    getSpecialLessons() {
      if (!this.courses[this.currentProfession] || !this.courses[this.currentProfession].specialLessons) {
        return [];
      }
      return this.courses[this.currentProfession].specialLessons;
    }

    selectDay(dayId) {
      const day = this.getDays().find(d => d.id === dayId);
      if (day) {
        this.currentDay = day;
        this.currentLesson = null;
        return day;
      }
      return null;
    }

    getLessonsForCurrentDay() {
      if (!this.currentDay) return [];
      return this.currentDay.lessons || [];
    }

    selectLesson(lessonId) {
      if (!this.courses || Object.keys(this.courses).length === 0) {
        console.error('Ошибка: курсы еще не загружены, невозможно выбрать урок');
        return null;
      }
      if (this.currentDay && this.currentDay.lessons) {
        const lesson = this.currentDay.lessons.find(l => l.id === lessonId);
        if (lesson) {
          this.currentLesson = lesson;
          console.log(`Выбран урок из текущего дня: ${lesson.title} (ID: ${lesson.id})`);
          return lesson;
        }
      }
      const specialLessons = this.getSpecialLessons();
      if (specialLessons && specialLessons.length > 0) {
        const specialLesson = specialLessons.find(l => l.id === lessonId);
        if (specialLesson) {
          this.currentLesson = specialLesson;
          console.log(`Выбран специальный урок: ${specialLesson.title} (ID: ${specialLesson.id})`);
          return specialLesson;
        }
      }
      console.error(`Урок с ID ${lessonId} не найден ни в текущем дне, ни в специальных уроках`);
      return null;
    }

    async fetchLessonContent() {
      if (!this.currentLesson) {
        console.error('Ошибка: текущий урок не выбран');
        return null;
      }
      console.log(`Загрузка контента для урока: ${this.currentLesson.id} (${this.currentLesson.title})`);
      const source = this.currentLesson.contentSource;
      if (!source) {
        console.error('Ошибка: у урока нет источника контента');
        return `# ${this.currentLesson.title}\n\nК сожалению, для данного урока не указан источник контента.`;
      }
      console.log(`Источник контента:`, source);
      this.showLoadingIndicator();
      const globalStatusElement = document.getElementById('global-loading-status');
      if (globalStatusElement) {
        globalStatusElement.textContent = `Загрузка контента урока "${this.currentLesson.title}"...`;
      }
      const globalLoadingOverlay = document.getElementById('global-loading-overlay');
      if (globalLoadingOverlay) {
        globalLoadingOverlay.style.display = 'flex';
        globalLoadingOverlay.style.opacity = '1';
      }
      try {
        let content = '';
        if (source.type === 'webhook' && source.url) {
          try {
            if (window.devMode && window.devMode.enabled) {
              console.log(`🔧 [DevMode] Загрузка контента урока '${this.currentLesson.title}' с URL: ${source.url}`);
            }
            console.log(`Fetching from: ${source.url}`);
            console.log(`Using simplified GET request`);
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000);
            const response = await fetch(source.url, {
              method: 'GET',
              headers: {
                'Accept': 'text/plain, text/markdown, text/html, application/json, */*',
                'Cache-Control': 'no-cache, no-store, must-revalidate',
                'Pragma': 'no-cache'
              },
              mode: 'cors',
              cache: 'no-store',
              signal: controller.signal
            });
            clearTimeout(timeoutId);
            console.log(`Response status: ${response.status}`);
            if (!response.ok) {
              throw new Error(`HTTP ошибка! Статус: ${response.status}`);
            }
            content = await response.text();
            console.log(`Response size: ${content.length} bytes`);
            console.log(`Response preview: "${content.substring(0, 100)}${content.length > 100 ? '...' : ''}"`);
            console.log(`Response received successfully!`);
            if (content.trim().startsWith('{') || content.trim().startsWith('[')) {
              try {
                const jsonData = JSON.parse(content);
                console.log('Получен JSON ответ, структура:', Object.keys(jsonData));
                if (jsonData.content) {
                  console.log('Используем поле content из JSON');
                  content = jsonData.content;
                }
                else if (jsonData.markdown) {
                  console.log('Используем поле markdown из JSON');
                  content = jsonData.markdown;
                }
                else if (jsonData.text) {
                  console.log('Используем поле text из JSON');
                  content = jsonData.text;
                }
                else if (jsonData.html) {
                  console.log('Используем поле html из JSON');
                  content = jsonData.html;
                }
                else if (jsonData.data && typeof jsonData.data === 'string') {
                  console.log('Используем поле data (строка) из JSON');
                  content = jsonData.data;
                }
              } catch (e) {
                console.log('Не удалось распарсить JSON, используем ответ как текст:', e.message);
              }
            }
            if (window.devMode && window.devMode.enabled) {
              console.log(`🔧 [DevMode] Контент урока успешно загружен (${content.length} символов)`);
            }
          } catch (error) {
            console.error('Ошибка загрузки контента с вебхука:', error);
            if (source.fallbackType === 'local' && source.fallbackId) {
              console.log('Используем резервный локальный контент:', source.fallbackId);
              if (window.devMode && window.devMode.enabled) {
                console.log(`🔧 [DevMode] Использование резервного контента с ID: ${source.fallbackId}`);
              }
              content = await this.fetchLocalContent(source.fallbackId);
            } else if (source.fallbackType === 'markdown' && source.fallbackContent) {
              console.log('Используем встроенный резервный markdown-контент');
              content = source.fallbackContent;
            } else {
              content = `# ${this.currentLesson.title}\n\n## Ошибка загрузки контента\n\nК сожалению, не удалось загрузить содержимое этого урока с сервера.\n\nОшибка: ${error.message}\n\nПожалуйста, попробуйте позже или обратитесь к руководителю команды.`;
            }
          }
        } else if (source.type === 'local' && source.id) {
          if (window.devMode && window.devMode.enabled) {
            console.log(`🔧 [DevMode] Загрузка локального контента с ID: ${source.id}`);
          }
          content = await this.fetchLocalContent(source.id);
        } else if (source.type === 'markdown' && source.content) {
          if (window.devMode && window.devMode.enabled) {
            console.log(`🔧 [DevMode] Использование встроенного Markdown контента (${source.content.length} символов)`);
          }
          content = source.content;
        }
        this.hideLoadingIndicator();
        return content;
      } catch (error) {
        console.error('Ошибка при загрузке контента урока:', error);
        if (window.devMode && window.devMode.enabled) {
          console.log(`🔧 [DevMode] Ошибка при загрузке контента урока: ${error.message}`);
        }
        this.hideLoadingIndicator();
        throw error;
      }
    }

    async fetchTest(lesson = this.currentLesson) {
      if (!lesson || !lesson.testSource) {
        return null;
      }
      try {
        const testSource = lesson.testSource;
        if (testSource.type === 'webhook') {
          try {
            const response = await fetch(testSource.url, {
              method: 'GET',
              headers: {
                'Accept': 'text/plain, text/markdown, application/json, */*'
              },
              mode: 'cors',
              cache: 'no-cache'
            });
            if (!response.ok) {
              throw new Error(`HTTP error! Status: ${response.status}`);
            }
            let content = await response.text();
            if (content.trim().startsWith('{') || content.trim().startsWith('[')) {
              try {
                const json = JSON.parse(content);
                if (json.test) content = json.test;
                else if (json.content) content = json.content;
                else if (json.markdown) content = json.markdown;
              } catch (e) {
                console.log('Не удалось распарсить JSON, используем ответ как текст');
              }
            }
            return content;
          } catch (error) {
            console.error(`Ошибка при загрузке теста с вебхука: ${error.message}`);
            if (testSource.fallbackType === 'markdown' && testSource.fallbackId) {
              try {
                const response = await fetch(`data/tests/${testSource.fallbackId}.md`);
                if (response.ok) {
                  return await response.text();
                }
              } catch (e) {
                console.error(`Не удалось загрузить локальный тест: ${e.message}`);
              }
            }
          }
        } else if (testSource.type === 'markdown' && testSource.id) {
          try {
            const response = await fetch(`data/tests/${testSource.id}.md`);
            if (response.ok) {
              return await response.text();
            }
          } catch (e) {
            console.error(`Не удалось загрузить локальный тест: ${e.message}`);
          }
        }
        return null;
      } catch (error) {
        console.error('Ошибка при загрузке теста:', error);
        return null;
      }
    }

    getTask(lesson = this.currentLesson) {
      if (!lesson || !lesson.taskSource) {
        return null;
      }
      const taskSource = lesson.taskSource;
      if (taskSource.type === 'markdown' && taskSource.content) {
        return taskSource.content;
      }
      return null;
    }

    getAudioInfo(lesson = this.currentLesson) {
      if (!lesson || !lesson.audioSource) {
        return null;
      }
      return lesson.audioSource;
    }

    showLoadingIndicator() {
      //Implementation for showing loading indicator
    }

    hideLoadingIndicator() {
      //Implementation for hiding loading indicator
    }

    async fetchLocalContent(id) {
      try {
        const response = await fetch(`data/content/${id}.md`);
        if (response.ok) {
          return await response.text();
        } else {
          throw new Error(`Не удалось загрузить локальный контент с ID ${id}: ${response.status}`);
        }
      } catch (error) {
        console.error("Ошибка загрузки локального контента:", error);
        return null;
      }
    }

    saveBackup() {
      if (this.courses) {
        localStorage.setItem('coursesBackup', JSON.stringify(this.courses));
        localStorage.setItem('coursesBackupTimestamp', new Date().toISOString());
        if (window.devMode && window.devMode.enabled) {
          console.log('🔧 [DevMode] Сохранена резервная копия курсов');
        }
      }
      if (this.fallbacks) {
        localStorage.setItem('fallbacksBackup', JSON.stringify(this.fallbacks));
        localStorage.setItem('fallbacksBackupTimestamp', new Date().toISOString());
      }
    }

    restoreFromBackup() {
      const coursesBackup = localStorage.getItem('coursesBackup');
      const fallbacksBackup = localStorage.getItem('fallbacksBackup');
      let restored = false;
      if (coursesBackup) {
        try {
          this.courses = JSON.parse(coursesBackup);
          const timestamp = localStorage.getItem('coursesBackupTimestamp') || 'неизвестно';
          console.log(`Восстановлены курсы из резервной копии (${timestamp})`);
          restored = true;
        } catch (e) {
          console.error('Ошибка при восстановлении курсов из резервной копии:', e);
        }
      }
      if (fallbacksBackup) {
        try {
          this.fallbacks = JSON.parse(fallbacksBackup);
          console.log('Восстановлен резервный контент из копии');
        } catch (e) {
          console.error('Ошибка при восстановлении резервного контента:', e);
        }
      }
      return restored;
    }

    onCoursesUpdated(callback) {
      if (typeof callback === 'function') {
        this.courseUpdateCallbacks.push(callback);
      }
    }

    notifyCoursesUpdated() {
      if (this.courseUpdateCallbacks && Array.isArray(this.courseUpdateCallbacks)) {
        this.courseUpdateCallbacks.forEach(callback => {
          try {
            callback(this.courses);
          } catch (error) {
            console.error('Ошибка при вызове подписчика обновления курсов:', error);
          }
        });
      }
    }
  }

  // Создаем экземпляр класса
  const courseManager = new CourseManager();
  window.courseManager = courseManager;
  // ==================== END COURSE MANAGER CODE ====================


  // ==================== BEGIN DEV MODE CODE ====================
  /**
   * Модуль режима разработчика
   * Позволяет отслеживать и отображать информацию о запросах и ответах в приложении
   */
  class DevMode {
    constructor() {
      this.enabled = true; // По умолчанию включен
      this.logs = [];
      this.maxLogs = 100; // Максимальное количество логов для хранения
      this.requestCounter = 0;
      this._initialized = false;
    }

    /**
     * Инициализация режима разработчика
     */
    initialize() {
      if (this._initialized) return;

      console.log('🔧 Инициализация режима разработчика...');
      this.createDevPanel();
      this.overrideFetch();
      this.overrideXHR();
      this.addDevModeToggle();
      this._initialized = true;
      console.log('🔧 Режим разработчика инициализирован');
    }

    /**
     * Создание панели разработчика
     */
    createDevPanel() {
      const devPanel = document.createElement('div');
      devPanel.id = 'dev-mode-panel';
      devPanel.className = 'dev-panel';
      devPanel.innerHTML = `
        <div class="dev-panel-header">
          <h3>Режим разработчика</h3>
          <div class="dev-panel-actions">
            <button id="dev-panel-standalone" title="Открыть Standalone версию"><i class="fas fa-external-link-alt"></i></button>
            <button id="dev-panel-analyze" title="Анализировать данные курсов"><i class="fas fa-chart-bar"></i></button>
            <button id="dev-panel-debug" title="Показать отладочную информацию"><i class="fas fa-bug"></i></button>
            <button id="dev-panel-storage" title="LocalStorage менеджер"><i class="fas fa-database"></i></button>
            <button id="dev-panel-sync" title="Синхронизировать с облаком"><i class="fas fa-sync-alt"></i></button>
            <button id="dev-panel-clear" title="Очистить логи"><i class="fas fa-trash"></i></button>
            <button id="dev-panel-minimize" title="Свернуть панель"><i class="fas fa-minus"></i></button>
          </div>
        </div>
        <div class="dev-panel-body">
          <div id="dev-panel-logs"></div>
        </div>
      `;

      document.body.appendChild(devPanel);
      this.addDevPanelStyles();
      document.getElementById('dev-panel-clear').addEventListener('click', () => {
        this.clearLogs();
      });
      document.getElementById('dev-panel-minimize').addEventListener('click', () => {
        devPanel.classList.toggle('minimized');
        if (devPanel.classList.contains('minimized')) {
          document.getElementById('dev-panel-minimize').innerHTML = '<i class="fas fa-plus"></i>';
        } else {
          document.getElementById('dev-panel-minimize').innerHTML = '<i class="fas fa-minus"></i>';
        }
      });
      document.getElementById('dev-panel-analyze').addEventListener('click', () => {
        this.analyzeAndDisplayCourses();
      });
      document.getElementById('dev-panel-sync').addEventListener('click', () => {
        this.syncWithCloud();
      });
      document.getElementById('dev-panel-debug').addEventListener('click', () => {
        this.showDebugInfo();
      });
      document.getElementById('dev-panel-storage').addEventListener('click', () => {
        this.showLocalStorageManager();
      });
      document.getElementById('dev-panel-standalone').addEventListener('click', () => {
        window.open('standalone.html', '_blank');
      });
    }

    /**
     * Добавление стилей для панели разработчика
     */
    addDevPanelStyles() {
      const styleElement = document.createElement('style');
      styleElement.textContent = `
        .dev-panel {
          position: fixed;
          bottom: 0;
          right: 0;
          width: 500px;
          max-width: 100%;
          height: 300px;
          background-color: rgba(40, 44, 52, 0.95);
          color: #eee;
          border-top-left-radius: 8px;
          box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
          font-family: 'Consolas', 'Monaco', monospace;
          font-size: 12px;
          z-index: 10000;
          display: flex;
          flex-direction: column;
          transition: all 0.3s ease;
        }

        .dev-panel.minimized {
          height: 36px;
          overflow: hidden;
        }

        .dev-panel-header {
          background-color: #1e2127;
          padding: 8px 10px;
          display: flex;
          justify-content: space-between;
          align-items: center;
          border-top-left-radius: 8px;
          user-select: none;
        }

        .dev-panel-header h3 {
          margin: 0;
          font-size: 14px;
          font-weight: normal;
        }

        .dev-panel-actions {
          display: flex;
          gap: 5px;
        }

        .dev-panel-actions button {
          background: none;
          border: none;
          color: #aaa;
          cursor: pointer;
          font-size: 12px;
          width: 20px;
          height: 20px;
          padding: 0;
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 3px;
        }

        .dev-panel-actions button:hover {
          background-color: rgba(255, 255, 255, 0.1);
          color: #fff;
        }

        .dev-panel-body {
          flex: 1;
          overflow-y: auto;
          padding: 10px;
        }

        #dev-panel-logs {
          font-family: 'Consolas', 'Monaco', monospace;
          font-size: 12px;
          line-height: 1.4;
        }

        .dev-log-entry {
          margin-bottom: 10px;
          padding-bottom: 10px;
          border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .dev-log-entry-header {
          display: flex;
          justify-content: space-between;
          margin-bottom: 3px;
        }

        .dev-log-timestamp {
          color: #aaa;
          font-size: 10px;
        }

        .dev-log-url {
          color: #61afef;
          word-break: break-all;
        }

        .dev-log-method {
          color: #98c379;
          font-weight: bold;
          margin-right: 5px;
        }

        .dev-log-status {
          font-weight: bold;
        }

        .dev-log-status.success {
          color: #98c379;
        }

        .dev-log-status.error {
          color: #e06c75;
        }

        .dev-log-button {
          padding: 2px 5px;
          background-color: rgba(255, 255, 255, 0.1);
          border: none;
          border-radius: 3px;
          color: #ddd;
          cursor: pointer;
          font-size: 11px;
          margin-top: 5px;
        }

        .dev-log-button:hover {
          background-color: rgba(255, 255, 255, 0.2);
        }

        .dev-log-details {
          background-color: rgba(0, 0, 0, 0.2);
          padding: 5px;
          margin-top: 5px;
          border-radius: 3px;
          display: none;
        }

        .dev-log-details.visible {
          display: block;
        }

        .dev-log-label {
          color: #d19a66;
          margin-right: 5px;
        }

        .dev-log-message {
          word-break: break-word;
        }

        .dev-log-message.success {
          color: #98c379;
        }

        .dev-log-message.error {
          color: #e06c75;
        }

        .dev-log-message.warning {
          color: #e5c07b;
        }

        .dev-log-message.info {
          color: #61afef;
        }

        .dev-info-badge {
          display: inline-flex;
          align-items: center;
          justify-content: center;
          width: 18px;
          height: 18px;
          border-radius: 50%;
          background-color: rgba(97, 175, 239, 0.8);
          color: white;
          font-size: 12px;
          cursor: pointer;
          margin-left: 5px;
          vertical-align: middle;
        }

        .dev-info-tooltip {
          position: absolute;
          background-color: #282c34;
          color: #eee;
          padding: 10px;
          border-radius: 5px;
          box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
          z-index: 10001;
          max-width: 400px;
          font-size: 12px;
          display: none;
        }

        .dev-info-tooltip.visible {
          display: block;
        }

        .dev-info-badge:hover + .dev-info-tooltip {
          display: block;
        }

        .dev-mode-toggle {
          position: fixed;
          top: 10px;
          right: 10px;
          background-color: rgba(40, 44, 52, 0.8);
          color: white;
          border: none;
          border-radius: 4px;
          padding: 5px 10px;
          cursor: pointer;
          font-size: 12px;
          z-index: 9999;
          display: flex;
          align-items: center;
          gap: 5px;
        }

        .dev-mode-toggle i {
          font-size: 14px;
        }

        .dev-mode-toggle.enabled {
          background-color: rgba(152, 195, 121, 0.8);
        }

        .dev-mode-toggle-hidden {
          display: none !important;
        }

        .admin-form-group {
          position: relative;
        }

        .admin-webhook-info {
          position: relative;
          display: inline-block;
        }

        @media (max-width: 768px) {
          .dev-panel {
            width: 100%;
            height: 200px;
          }
        }
      `;
      document.head.appendChild(styleElement);
    }

    addDevModeToggle() {
      const toggle = document.createElement('button');
      toggle.id = 'dev-mode-toggle';
      toggle.className = 'dev-mode-toggle' + (this.enabled ? ' enabled' : '');
      toggle.innerHTML = `
        <i class="fas fa-code"></i>
        <span>Режим разработчика</span>
      `;
      toggle.addEventListener('click', () => {
        this.toggleDevMode();
      });
      document.body.appendChild(toggle);
    }

    toggleDevMode() {
      this.enabled = !this.enabled;
      const toggle = document.getElementById('dev-mode-toggle');
      const devPanel = document.getElementById('dev-mode-panel');
      if (this.enabled) {
        toggle.classList.add('enabled');
        devPanel.style.display = 'flex';
        this.addInfoBadgesToAdminForms();
      } else {
        toggle.classList.remove('enabled');
        devPanel.style.display = 'none';
        this.removeInfoBadgesFromAdminForms();
      }
      console.log(`🔧 Режим разработчика ${this.enabled ? 'включен' : 'выключен'}`);
    }

    overrideFetch() {
      const originalFetch = window.fetch;
      const self = this;
      window.fetch = function(resource, init) {
        const startTime = performance.now();
        const requestId = ++self.requestCounter;
        let method = 'GET';
        let requestBody = null;
        if (init) {
          method = init.method || 'GET';
          requestBody = init.body || null;
        }
        const requestInfo = {
          id: requestId,
          url: resource instanceof Request ? resource.url : resource,
          method: method,
          headers: init?.headers ? (init.headers instanceof Headers ? Object.fromEntries(init.headers.entries()) : init.headers) : {},
          body: requestBody,
          timestamp: new Date(),
          startTime: startTime
        };
        if (self.enabled) {
          self.logRequest(requestInfo);
        }
        return originalFetch.apply(this, arguments)
          .then(response => {
            const endTime = performance.now();
            const duration = endTime - startTime;
            const clonedResponse = response.clone();
            clonedResponse.text().then(responseText => {
              const responseInfo = {
                status: response.status,
                statusText: response.statusText,
                headers: Object.fromEntries(response.headers.entries()),
                body: responseText,
                duration: duration.toFixed(2)
              };
              if (self.enabled) {
                self.logResponse(requestId, responseInfo);
              }
            }).catch(err => {
              console.error('Ошибка при чтении тела ответа:', err);
            });
            return response;
          })
          .catch(error => {
            const endTime = performance.now();
            const duration = endTime - startTime;
            if (self.enabled) {
              self.logError(requestId, error, duration.toFixed(2));
            }
            throw error;
          });
      };
    }

    overrideXHR() {
      const self = this;
      const originalOpen = XMLHttpRequest.prototype.open;
      const originalSend = XMLHttpRequest.prototype.send;
      XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
        this._devModeInfo = {
          id: ++self.requestCounter,
          method: method,
          url: url,
          timestamp: new Date(),
          startTime: performance.now()
        };
        return originalOpen.apply(this, arguments);
      };
      XMLHttpRequest.prototype.send = function(body) {
        if (this._devModeInfo) {
          this._devModeInfo.body = body;
          if (self.enabled) {
            self.logRequest(this._devModeInfo);
          }
          this.addEventListener('load', function() {
            const endTime = performance.now();
            const duration = endTime - this._devModeInfo.startTime;
            const responseInfo = {
              status: this.status,
              statusText: this.statusText,
              headers: this.getAllResponseHeaders().split('\r\n').reduce((result, header) => {
                const parts = header.split(': ');
                if (parts[0] && parts[1]) {
                  result[parts[0]] = parts[1];
                }
                return result;
              }, {}),
              body: this.responseText,
              duration: duration.toFixed(2)
            };
            if (self.enabled) {
              self.logResponse(this._devModeInfo.id, responseInfo);
            }
          });
          this.addEventListener('error', function(error) {
            const endTime = performance.now();
            const duration = endTime - this._devModeInfo.startTime;
            if (self.enabled) {
              self.logError(this._devModeInfo.id, new Error('Network Error'), duration.toFixed(2));
            }
          });
          this.addEventListener('timeout', function() {
            const endTime = performance.now();
            const duration = endTime - this._devModeInfo.startTime;
            if (self.enabled) {
              self.logError(this._devModeInfo.id, new Error('Request Timeout'), duration.toFixed(2));
            }
          });
        }
        return originalSend.apply(this, arguments);
      };
    }

    logRequest(requestInfo) {
      const requestLog = {
        id: requestInfo.id,
        type: 'request',
        method: requestInfo.method,
        url: requestInfo.url,
        headers: requestInfo.headers,
        body: requestInfo.body,
        timestamp: requestInfo.timestamp,
        startTime: requestInfo.startTime
      };
      this.logs.push(requestLog);
      this.trimLogs();
      this.renderLogEntry(requestLog);
    }

    logResponse(requestId, responseInfo) {
      const requestLog = this.logs.find(log => log.id === requestId && log.type === 'request');
      if (requestLog) {
        const responseLog = {
          id: requestId,
          type: 'response',
          status: responseInfo.status,
          statusText: responseInfo.statusText,
          headers: responseInfo.headers,
          body: responseInfo.body,
          duration: responseInfo.duration,
          timestamp: new Date()
        };
        this.logs.push(responseLog);
        this.trimLogs();
        this.updateLogEntry(requestId, responseLog);
      }
    }

    logError(requestId, error, duration) {
      const requestLog = this.logs.find(log => log.id === requestId && log.type === 'request');
      if (requestLog) {
        const errorLog = {
          id: requestId,
          type: 'error',
          error: error.message || 'Unknown error',
          stack: error.stack,
          duration: duration,
          timestamp: new Date()
        };
        this.logs.push(errorLog);
        this.trimLogs();
        this.updateLogEntry(requestId, errorLog);
      }
    }

    trimLogs() {
      if (this.logs.length > this.maxLogs) {
        const logsToRemove = this.logs.length - this.maxLogs;
        this.logs.splice(0, logsToRemove);
      }
    }

    renderLogEntry(log) {
      const logsContainer = document.getElementById('dev-panel-logs');
      if (!logsContainer) return;
      const logEntry = document.createElement('div');
      logEntry.id = `dev-log-${log.id}`;
      logEntry.className = 'dev-log-entry';
      const timestamp = new Date(log.timestamp).toLocaleTimeString();
      if (log.type === 'request') {
        logEntry.innerHTML = `
          <div class="dev-log-entry-header">
            <span>
              <span class="dev-log-method">${log.method}</span>
              <span class="dev-log-url">${this.truncateString(log.url, 60)}</span>
            </span>
            <span class="dev-log-timestamp">${timestamp}</span>
          </div>
          <div>
            <button class="dev-log-button" onclick="window.devMode.toggleLogDetails(${log.id})">Детали</button>
          </div>
          <div id="dev-log-details-${log.id}" class="dev-log-details">
            <div><span class="dev-log-label">URL:</span> ${log.url}</div>
            <div><span class="dev-log-label">Метод:</span> ${log.method}</div>
            <div><span class="dev-log-label">Заголовки:</span> ${this.formatJson(log.headers)}</div>
            ${log.body ? `<div><span class="dev-log-label">Тело запроса:</span> ${this.formatRequestBody(log.body)}</div>` : ''}
          </div>
        `;
      }
      logsContainer.prepend(logEntry);
    }

    updateLogEntry(requestId, log) {
      const logEntry = document.getElementById(`dev-log-${requestId}`);
      if (!logEntry) return;
      const logDetails = document.getElementById(`dev-log-details-${requestId}`);
      if (log.type === 'response') {
        const statusClass = log.status >= 200 && log.status < 400 ? 'success' : 'error';
        const logHeader = logEntry.querySelector('.dev-log-entry-header');
        if (logHeader) {
          logHeader.insertAdjacentHTML('beforeend', `
            <span class="dev-log-status ${statusClass}">${log.status}</span>
          `);
        }
        const logActions = logEntry.querySelector('.dev-log-button').parentNode;
        if (logActions) {
          logActions.insertAdjacentHTML('beforeend', `
            <span style="margin-left: 10px; color: #aaa;">Длительность: ${log.duration} мс</span>
          `);
        }
        if (logDetails) {
          logDetails.insertAdjacentHTML('beforeend', `
            <div style="margin-top: 10px; border-top: 1px solid rgba(255, 255, 255, 0.1); padding-top: 5px;">
              <div><span class="dev-log-label">Статус:</span> ${log.status} ${log.statusText}</div>
              <div><span class="dev-log-label">Заголовки ответа:</span> ${this.formatJson(log.headers)}</div>
              <div><span class="dev-log-label">Тело ответа:</span> ${this.formatResponseBody(log.body)}</div>
            </div>
          `);
        }
      } else if (log.type === 'error') {
        const logHeader = logEntry.querySelector('.dev-log-entry-header');
        if (logHeader) {
          logHeader.insertAdjacentHTML('beforeend', `
            <span class="dev-log-status error">ERROR</span>
          `);
        }
        const logActions = logEntry.querySelector('.dev-log-button').parentNode;
        if (logActions) {
          logActions.insertAdjacentHTML('beforeend', `
            <span style="margin-left: 10px; color: #aaa;">Длительность: ${log.duration} мс</span>
          `);
        }
        if (logDetails) {
          logDetails.insertAdjacentHTML('beforeend', `
            <div style="margin-top: 10px; border-top: 1px solid rgba(255, 255, 255, 0.1); padding-top: 5px;">
              <div><span class="dev-log-label">Ошибка:</span> <span style="color: #e06c75;">${log.error}</span></div>
              ${log.stack ? `<div><span class="dev-log-label">Стек:</span> <pre style="margin: 5px 0; white-space: pre-wrap;">${log.stack}</pre></div>` : ''}
            </div>
          `);
        }
      }
    }

    toggleLogDetails(logId) {
      const logDetails = document.getElementById(`dev-log-details-${logId}`);
      if (logDetails) {
        logDetails.classList.toggle('visible');
      }
    }

    formatJson(obj) {
      try {
        if (!obj) return 'null';
        const jsonString = JSON.stringify(obj, null, 2);
        return `<pre style="margin: 5px 0;">${this.highlightJson(jsonString)}</pre>`;
      } catch (error) {
        return String(obj);
      }
    }

    highlightJson(jsonString) {
      return jsonString
        .replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, (match) => {
          let cls = 'number';
          if (/^"/.test(match)) {
            if (/:$/.test(match)) {
              cls = 'key';
              match = match.replace(/"/, '<span style="color: #d19a66;">').replace(/":\s*$/, '</span>:');
              return match;
            } else {
              cls = 'string';
              return `<span style="color: #98c379;">${match}</span>`;
            }
          } else if (/true|false/.test(match)) {
            cls = 'boolean';
            return `<span style="color: #56b6c2;">${match}</span>`;
          } else if (/null/.test(match)) {
            cls = 'null';
            return `<span style="color: #56b6c2;">${match}</span>`;
          } else {
            return `<span style="color: #d19a66;">${match}</span>`;
          }
        });
    }

    formatRequestBody(body) {
      if (!body) return 'null';
      if (typeof body === 'string') {
        try {
          const json = JSON.parse(body);
          return this.formatJson(json);
        } catch (e) {
          return `<pre style="margin: 5px 0; white-space: pre-wrap;">${body}</pre>`;
        }
      } else if (body instanceof FormData) {
        const entries = Array.from(body.entries());
        if (entries.length === 0) return 'FormData (пусто)';
        const formDataObj = {};
        entries.forEach(([key, value]) => {
          formDataObj[key] = value instanceof File ? `File: ${value.name} (${value.type}, ${value.size} bytes)` : value;
        });
        return this.formatJson(formDataObj);
      } else if (body instanceof Blob) {
        return `Blob (${body.type}, ${body.size} bytes)`;
      } else {
        return this.formatJson(body);
      }
    }

    formatResponseBody(body) {
      if (!body) return 'null';
      try {
        const json = JSON.parse(body);
        return this.formatJson(json);
      } catch (e) {
        if (body.length > 5000) {
          return `<pre style="margin: 5px 0; white-space: pre-wrap;">${body.substring(0, 5000)}...</pre>
                  <button class="dev-log-button" onclick="navigator.clipboard.writeText(\`${body.replace(/`/g, '\\`')}\`).then(() => alert('Скопировано в буфер обмена!'))">Скопировать полностью</button>`;
        }
        return `<pre style="margin: 5px 0; white-space: pre-wrap;">${body}</pre>`;
      }
    }

    addInfoBadgesToAdminForms() {
      const webhookFields = [
        { 
          id: 'admin-export-webhook-url', 
          description: 'URL для экспорта данных. При сохранении курса данные будут отправлены на этот URL в формате JSON.'
        },
        { 
          id: 'admin-import-webhook-url', 
          description: 'URL для импорта данных. При импорте данные будут запрошены с этого URL.'
        },
        { 
          id: 'admin-get-webhooks-url', 
          description: 'URL для получения списка доступных вебхуков. Используется для автоматического заполнения полей экспорта и импорта.'
        },
        { 
          id: 'admin-content-webhook-url', 
          description: 'URL для получения контента урока. Система отправит GET-запрос на этот URL и отобразит полученный Markdown или HTML.'
        },
        { 
          id: 'admin-test-webhook-url', 
          description: 'URL для получения теста. Система отправит GET-запрос на этот URL и отобразит полученный тест.'
        }
      ];

      webhookFields.forEach(field => {
        const input = document.getElementById(field.id);
        if (input) {
          const label = input.previousElementSibling;
          if (label) {
            const infoBadge = document.createElement('span');
            infoBadge.className = 'dev-info-badge';
            infoBadge.textContent = 'i';
            infoBadge.setAttribute('data-tooltip', field.description);
            infoBadge.addEventListener('click', (e) => {
              e.stopPropagation();
              this.showInfoTooltip(e.target, field.description);
            });
            label.appendChild(infoBadge);
          }
        }
      });
    }

    removeInfoBadgesFromAdminForms() {
      document.querySelectorAll('.dev-info-badge').forEach(badge => {
        badge.remove();
      });
      document.querySelectorAll('.dev-info-tooltip').forEach(tooltip => {
        tooltip.remove();
      });
    }

    showInfoTooltip(element, text) {
      document.querySelectorAll('.dev-info-tooltip').forEach(tooltip => {
        tooltip.remove();
      });
      const tooltip = document.createElement('div');
      tooltip.className = 'dev-info-tooltip';
      tooltip.textContent = text;
      tooltip.style.left = `${element.offsetLeft + element.offsetWidth + 5}px`;
      tooltip.style.top = `${element.offsetTop - 5}px`;
      document.body.appendChild(tooltip);
      document.addEventListener('click', function closeTooltip(e) {
        if (e.target !== tooltip && e.target !== element) {
          tooltip.remove();
          document.removeEventListener('click', closeTooltip);
        }
      });
      setTimeout(() => {
        tooltip.classList.add('visible');
      }, 10);
    }

    clearLogs() {
      this.logs = [];
      document.getElementById('dev-panel-logs').innerHTML = '';
    }

    truncateString(str, maxLength) {
      if (str.length <= maxLength) return str;
      return str.substring(0, maxLength) + '...';
    }

    async syncWithCloud() {
      const webhookSettingsStr = localStorage.getItem('webhookSettings');
      if (!webhookSettingsStr) {
        this.logMessage('Ошибка синхронизации: настройки вебхуков не найдены в localStorage', 'error');
        return;
      }
      try {
        const webhookSettings = JSON.parse(webhookSettingsStr);
        if (webhookSettings.importUrl) {
          this.logMessage(`Выполняется синхронизация с облаком. URL импорта: ${webhookSettings.importUrl}`, 'info');
          try {
            const response = await fetch(webhookSettings.importUrl, {
              method: 'GET',
              headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json'
              }
            });
            if (response.ok) {
              const contentType = response.headers.get('content-type') || '';
              this.logMessage(`Получен ответ с Content-Type: ${contentType}`, 'info');
              const text = await response.text();
              this.logMessage(`Получены данные (${text.length} символов)`, 'info');
              let data;
              try {
                data = JSON.parse(text);
                this.logMessage('Данные успешно распарсены как JSON', 'success');
              } catch (e) {
                this.logMessage(`Не удалось распарсить как JSON: ${e.message}`, 'warning');
                if (text.includes('"data"')) {
                  try {
                    const regex = /"data"\s*:\s*"(.*?)"/s;
                    const match = text.match(regex);
                    if (match && match[1]) {
                      let jsonString = match[1].replace(/\\"/g, '"').replace(/\\n/g, '\n').replace(/\\\\/g, '\\');
                      while (jsonString.includes('\\')) {
                        jsonString = jsonString.replace(/\\"/g, '"').replace(/\\n/g, '\n').replace(/\\\\/g, '\\');
                      }
                      this.logMessage('Извлечен JSON из поля "data"', 'info');
                      data = { courses: JSON.parse(jsonString) };
                    }
                  } catch (innerError) {
                    this.logMessage(`Не удалось распарсить данные из поля data: ${innerError.message}`, 'error');
                  }
                }
              }
              if (!data) {
                this.logMessage('Не удалось распарсить данные из ответа. Проверьте формат ответа сервера.', 'error');
                return;
              }
              if (!data.courses) {
                if (typeof data === 'object' && Object.keys(data).length > 0) {
                  const courseCandidate = Object.values(data).find(item => 
                    item && typeof item === 'object' && 
                    (item.days || item.specialLessons || item.title)
                  );
                  if (courseCandidate) {
                    this.logMessage('Используем полученный объект как courses', 'info');
                    data = { courses: data };
                  }
                }
                if (!data.courses) {
                  this.logMessage('Полученные данные не содержат информацию о курсах', 'error');
                  return;
                }
              }
              const courseCount = Object.keys(data.courses).length;
              this.logMessage(`Получены данные курсов (${courseCount} курсов)`, 'success');
              this.logMessage(`Идентификаторы курсов: ${Object.keys(data.courses).join(', ')}`, 'info');
              const backupCourses = JSON.parse(JSON.stringify(window.courseManager.courses));
              try {
                window.courseManager.courses = data.courses;
                this.logMessage('Данные успешно импортированы и применены', 'success');
                if (window.adminInterface && window.adminInterface.loadCoursesList) {
                  window.adminInterface.loadCoursesList();
                }
                localStorage.setItem('coursesBackup', JSON.stringify(backupCourses));
                localStorage.setItem('coursesBackupTimestamp', new Date().toISOString());
                if (window.adminInterface && window.adminInterface.exportDataToWebhook) {
                  this.logMessage(`Экспорт обновленных данных на ${webhookSettings.exportUrl}`, 'info');
                  window.adminInterface.exportDataToWebhook(webhookSettings.exportUrl);
                }
              } catch (e) {
                window.courseManager.courses = backupCourses;
                this.logMessage(`Ошибка при применении импортированных данных: ${e.message}`, 'error');
                this.logMessage('Восстановлена предыдущая версия курсов', 'warning');
              }
            } else {
              this.logMessage(`Ошибка HTTP! Статус: ${response.status}`, 'error');
            }
          } catch (error) {
            this.logMessage(`Ошибка при синхронизации с облаком: ${error.message}`, 'error');
          }
        } else {
          this.logMessage('URL для импорта не найден в настройках вебхуков', 'error');
        }
      } catch (e) {
        this.logMessage(`Ошибка при обработке настроек вебхуков: ${e.message}`, 'error');
      }
    }

    logMessage(message, type = 'info') {
      const logsContainer = document.getElementById('dev-panel-logs');
      if (!logsContainer) return;
      const timestamp = new Date().toLocaleTimeString();
      let typeClass;
      switch (type) {
        case 'success': typeClass = 'success'; break;
        case 'error': typeClass = 'error'; break;
        case 'warning': typeClass = 'warning'; break;
        default: typeClass = 'info';
      }
      const logEntry = document.createElement('div');
      logEntry.className = 'dev-log-entry';
      logEntry.innerHTML = `
        <div class="dev-log-entry-header">
          <span class="dev-log-message ${typeClass}">${message}</span>
          <span class="dev-log-timestamp">${timestamp}</span>
        </div>
      `;
      logsContainer.prepend(logEntry);
      console.log(`🔧 [DevMode] ${message}`);
    }

    showDebugInfo() {
      if (!window.courseManager) {
        this.logMessage('CourseManager не инициализирован', 'error');
        return;
      }
      this.logMessage(`Текущая профессия: ${window.courseManager.currentProfession || 'не выбрана'}`, 'info');
      this.logMessage(`Текущий день: ${window.courseManager.currentDay ? window.courseManager.currentDay.id : 'не выбран'}`, 'info');
      this.logMessage(`Текущий урок: ${window.courseManager.currentLesson ? window.courseManager.currentLesson.id : 'не выбран'}`, 'info');
      const daySelectionContainer = document.getElementById('day-selection');
      const taskSelectionContainer = document.getElementById('task-selection');
      const homeContainer = document.getElementById('home');
      const guideContainer = document.getElementById('guide');
      this.logMessage(`Состояние контейнеров в DOM:`, 'info');
      this.logMessage(`- home: ${homeContainer ? (homeContainer.classList.contains('hidden') ? 'скрыт' : 'виден') : 'не найден'}`, 'info');
      this.logMessage(`- day-selection: ${daySelectionContainer ? (daySelectionContainer.classList.contains('hidden') ? 'скрыт' : 'виден') : 'не найден'}`, 'info');
      this.logMessage(`- task-selection: ${taskSelectionContainer ? (taskSelectionContainer.classList.contains('hidden') ? 'скрыт' : 'виден') : 'не найден'}`, 'info');
      this.logMessage(`- guide: ${guideContainer ? (guideContainer.classList.contains('hidden') ? 'скрыт' : 'виден') : 'не найден'}`, 'info');
      const days = window.courseManager.getDays();
      this.logMessage(`Доступно дней: ${days ? days.length : 0}`, 'info');
      if (days && days.length > 0) {
        days.forEach((day, index) => {
          this.logMessage(`День ${index+1}: ID=${day.id}, title=${day.title}, уроков: ${day.lessons ? day.lessons.length : 0}`, 'info');
        });
      }
    }

    showLocalStorageManager() {
      const storageReport = document.createElement('div');
      storageReport.className = 'dev-storage-report';
      const keys = Object.keys(localStorage);
      const totalSize = this.calculateLocalStorageSize();
      const summaryInfo = document.createElement('div');
      summaryInfo.className = 'dev-summary-info';
      summaryInfo.style.backgroundColor = 'rgba(0, 0, 0, 0.2)';
      summaryInfo.style.padding = '10px';
      summaryInfo.style.borderRadius = '4px';
      summaryInfo.style.marginBottom = '15px';
      const buttonsContainer = document.createElement('div');
      buttonsContainer.style.marginBottom = '10px';
      buttonsContainer.style.display = 'flex';
      buttonsContainer.style.gap = '10px';
      const clearAllButton = document.createElement('button');
      clearAllButton.innerText = 'Очистить весь LocalStorage';
      clearAllButton.style.backgroundColor = '#e06c75';
      clearAllButton.style.color = 'white';
      clearAllButton.style.border = 'none';
      clearAllButton.style.padding = '8px 15px';
      clearAllButton.style.borderRadius = '4px';
      clearAllButton.style.cursor = 'pointer';
      clearAllButton.onclick = () => {
        if (confirm('Вы уверены, что хотите очистить весь LocalStorage? Это действие нельзя отменить.')) {
          localStorage.clear();
          this.logMessage('LocalStorage полностью очищен', 'success');
          this.showLocalStorageManager();
        }
      };
      const refreshButton = document.createElement('button');
      refreshButton.innerText = 'Обновить';
      refreshButton.style.backgroundColor = '#61afef';
      refreshButton.style.color = 'white';
      refreshButton.style.border = 'none';
      refreshButton.style.padding = '8px 15px';
      refreshButton.style.borderRadius = '4px';
      refreshButton.style.cursor = 'pointer';
      refreshButton.onclick = () => {
        this.showLocalStorageManager();
      };
      buttonsContainer.appendChild(refreshButton);
      buttonsContainer.appendChild(clearAllButton);
      summaryInfo.appendChild(buttonsContainer);
      summaryInfo.innerHTML += `
        <div style="font-weight: bold; color: #56b6c2; margin-bottom: 5px;">Информация о LocalStorage:</div>
        <div><span style="color: #d19a66;">Количество элементов:</span> ${keys.length}</div>
        <div><span style="color: #d19a66;">Общий размер:</span> ${totalSize} KB</div>
        <div><span style="color: #d19a66;">Использовано:</span> ${((totalSize / 5120) * 100).toFixed(2)}% (приблизительно)</div>
      `;
      storageReport.appendChild(summaryInfo);
      const table = document.createElement('table');
      table.className = 'dev-storage-table';
      table.style.width = '100%';
      table.style.borderCollapse = 'collapse';
      table.style.marginBottom = '15px';
      table.style.fontSize = '12px';
      const thead = document.createElement('thead');
      thead.innerHTML = `
        <tr style="background-color: #1e2127; color: #ddd;">
          <th style="padding: 8px; text-align: left; border-bottom: 1px solid #444;">Ключ</th>
          <th style="padding: 8px; text-align: left; border-bottom: 1px solid #444;">Тип</th>
          <th style="padding: 8px; text-align: right; border-bottom: 1px solid #444;">Размер</th>
          <th style="padding: 8px; text-align: center; border-bottom: 1px solid #444;">Действия</th>
        </tr>
      `;
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      keys.sort((a, b) => {
        const sizeA = localStorage.getItem(a).length;
        const sizeB = localStorage.getItem(b).length;
        return sizeB - sizeA;
      });
      keys.forEach(key => {
        const value = localStorage.getItem(key);
        const size = value.length;
        const sizeKB = (size / 1024).toFixed(2);
        let type = 'Текст';
        let isJSON = false;
        try {
          const parsed = JSON.parse(value);
          type = typeof parsed === 'object' ? 'JSON' : typeof parsed;
          isJSON = typeof parsed === 'object';
        } catch (e) {}
        const tr = document.createElement('tr');
        tr.style.borderBottom = '1px solid rgba(255, 255, 255, 0.1)';
        tr.innerHTML = `
          <td style="padding: 8px;">${key}</td>
          <td style="padding: 8px; color: ${type === 'JSON' ? '#98c379' : '#e5c07b'};">${type}</td>
          <td style="padding: 8px; text-align: right;">${sizeKB} KB</td>
          <td style="padding: 8px; text-align: center;">
            <button class="dev-storage-view-btn" data-key="${key}" style="background-color: #56b6c2; color: white; border: none; border-radius: 3px; padding: 3px 8px; margin-right: 5px; cursor: pointer;">Просмотр</button>
            <button class="dev-storage-edit-btn" data-key="${key}" data-is-json="${isJSON}" style="background-color: #98c379; color: white; border: none; border-radius: 3px; padding: 3px 8px; margin-right: 5px; cursor: pointer;">Редактировать</button>
            <button class="dev-storage-delete-btn" data-key="${key}" style="background-color: #e06c75; color: white; border: none; border-radius: 3px; padding: 3px 8px; cursor: pointer;">Удалить</button>
          </td>
        `;
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      storageReport.appendChild(table);
      const logEntry = document.createElement('div');
      logEntry.className = 'dev-log-entry';
      logEntry.style.padding = '10px';
      const timestamp = new Date().toLocaleTimeString();
      logEntry.innerHTML = `
        <div class="dev-log-entry-header">
          <span class="dev-log-message info">Менеджер LocalStorage</span>
          <span class="dev-log-timestamp">${timestamp}</span>
        </div>
        <div style="margin-top: 10px;" id="storage-view-container">
          ${storageReport.outerHTML}
        </div>
      `;
      const logsContainer = document.getElementById('dev-panel-logs');
      if (logsContainer) {
        logsContainer.prepend(logEntry);
        this.setupStorageEventHandlers();
        logEntry.scrollIntoView({ behavior: 'smooth' });
      }
      this.logMessage('Менеджер LocalStorage открыт', 'info');
    }

    setupStorageEventHandlers() {
      document.querySelectorAll('.dev-storage-view-btn').forEach(button => {
        button.addEventListener('click', (e) => {
          const key = e.target.getAttribute('data-key');
          const value = localStorage.getItem(key);
          this.showStorageItemDetails(key, value);
        });
      });
      document.querySelectorAll('.dev-storage-edit-btn').forEach(button => {
        button.addEventListener('click', (e) => {
          const key = e.target.getAttribute('data-key');
          const isJSON = e.target.getAttribute('data-is-json') === 'true';
          const value = localStorage.getItem(key);
          this.editStorageItem(key, value, isJSON);
        });
      });
      document.querySelectorAll('.dev-storage-delete-btn').forEach(button => {
        button.addEventListener('click', (e) => {
          const key = e.target.getAttribute('data-key');
          if (confirm(`Вы уверены, что хотите удалить элемент "${key}" из LocalStorage?`)) {
            localStorage.removeItem(key);
            this.logMessage(`Элемент "${key}" удален из LocalStorage`, 'success');
            this.showLocalStorageManager();
          }
        });
      });
    }

    showStorageItemDetails(key, value) {
      const viewContainer = document.createElement('div');
      viewContainer.className = 'dev-storage-view-container';
      viewContainer.style.padding = '10px';
      viewContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
      viewContainer.style.borderRadius = '4px';
      viewContainer.style.marginTop = '10px';
      const header = document.createElement('div');
      header.style.display = 'flex';
      header.style.justifyContent = 'space-between';
      header.style.alignItems = 'center';
      header.style.marginBottom = '10px';
      header.innerHTML = `
        <h3 style="margin: 0; color: #56b6c2;">Просмотр элемента: ${key}</h3>
        <button id="close-storage-view" style="background: none; border: none; color: #aaa; cursor: pointer;">
          <i class="fas fa-times"></i>
        </button>
      `;
      viewContainer.appendChild(header);
      let formattedValue = value;
      try {
        const parsedValue = JSON.parse(value);
        formattedValue = this.formatJson(parsedValue);
      } catch (e) {
        formattedValue = `<pre style="margin: 0; white-space: pre-wrap; word-wrap: break-word;">${this.escapeHtml(value)}</pre>`;
      }
      const content = document.createElement('div');
      content.style.maxHeight = '400px';
      content.style.overflow = 'auto';
      content.style.backgroundColor = 'rgba(0, 0, 0, 0.2)';
      content.style.padding = '10px';
      content.style.borderRadius = '3px';
      content.innerHTML = formattedValue;
      viewContainer.appendChild(content);
      const actions = document.createElement('div');
      actions.style.marginTop = '10px';
      actions.style.display = 'flex';
      actions.style.gap = '10px';
      const copyButton = document.createElement('button');
      copyButton.innerText = 'Копировать';
      copyButton.style.backgroundColor = '#61afef';
      copyButton.style.color = 'white';
      copyButton.style.border = 'none';
      copyButton.style.padding = '5px 10px';
      copyButton.style.borderRadius = '3px';
      copyButton.style.cursor = 'pointer';
      copyButton.addEventListener('click', () => {
        navigator.clipboard.writeText(value).then(() => {
          this.logMessage(`Значение ключа "${key}" скопировано в буфер обмена`, 'success');
        }).catch(err => {
          this.logMessage(`Ошибка при копировании: ${err}`, 'error');
        });
      });
      actions.appendChild(copyButton);
      viewContainer.appendChild(actions);
      const logEntry = document.createElement('div');
      logEntry.className = 'dev-log-entry';
      logEntry.style.padding = '10px';
      const timestamp = new Date().toLocaleTimeString();
      logEntry.innerHTML = `
        <div class="dev-log-entry-header">
          <span class="dev-log-message info">Просмотр элемента LocalStorage</span>
          <span class="dev-log-timestamp">${timestamp}</span>
        </div>
        <div style="margin-top: 10px;" id="storage-view-container">
          ${viewContainer.outerHTML}
        </div>
      `;
      const logsContainer = document.getElementById('dev-panel-logs');
      if (logsContainer) {
        logsContainer.prepend(logEntry);
        document.getElementById('close-storage-view').addEventListener('click', () => {
          logEntry.remove();
        });
        logEntry.scrollIntoView({ behavior: 'smooth' });
      }
    }

    editStorageItem(key, value, isJSON) {
      const editContainer = document.createElement('div');
      editContainer.className = 'dev-storage-edit-container';
      editContainer.style.padding = '10px';
      editContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
      editContainer.style.borderRadius = '4px';
      editContainer.style.marginTop = '10px';
      const header = document.createElement('div');
      header.style.display = 'flex';
      header.style.justifyContent = 'space-between';
      header.style.alignItems = 'center';
      header.style.marginBottom = '10px';
      header.innerHTML = `
        <h3 style="margin: 0; color: #98c379;">Редактирование элемента: ${key}</h3>
        <button id="close-storage-edit" style="background: none; border: none; color: #aaa; cursor: pointer;">
          <i class="fas fa-times"></i>
        </button>
      `;
      editContainer.appendChild(header);
      let formattedValue = value;
      if (isJSON) {
        try {
          const parsedValue = JSON.parse(value);
          formattedValue = JSON.stringify(parsedValue, null, 2);
        } catch (e) {}
      }
      const textarea = document.createElement('textarea');
      textarea.id = 'storage-edit-textarea';
      textarea.style.width = '100%';
      textarea.style.height = '300px';
      textarea.style.backgroundColor = 'rgba(30, 33, 39, 0.9)';
      textarea.style.color = '#eee';
      textarea.style.border = '1px solid #444';
      textarea.style.borderRadius = '3px';
      textarea.style.padding = '10px';
      textarea.style.fontFamily = 'Consolas, Monaco, monospace';
      textarea.style.fontSize = '12px';
      textarea.value = formattedValue;
      editContainer.appendChild(textarea);
      const actions = document.createElement('div');
      actions.style.marginTop = '10px';
      actions.style.display = 'flex';
      actions.style.gap = '10px';
      const saveButton = document.createElement('button');
      saveButton.innerText = 'Сохранить';
      saveButton.style.backgroundColor = '#98c379';
      saveButton.style.color = 'white';
      saveButton.style.border = 'none';
      saveButton.style.padding = '5px 10px';
      saveButton.style.borderRadius = '3px';
      saveButton.style.cursor = 'pointer';
      const formatButton = document.createElement('button');
      formatButton.innerText = 'Форматировать JSON';
      formatButton.style.backgroundColor = '#61afef';
      formatButton.style.color = 'white';
      formatButton.style.border = 'none';
      formatButton.style.padding = '5px 10px';
      formatButton.style.borderRadius = '3px';
      formatButton.style.cursor = 'pointer';
      formatButton.addEventListener('click', () => {
        try {
          const parsedValue = JSON.parse(textarea.value);
          textarea.value = JSON.stringify(parsedValue, null, 2);
          this.logMessage('JSON успешно отформатирован', 'success');
        } catch (e) {
          this.logMessage(`Ошибка форматирования: ${e.message}`, 'error');
        }
      });
      saveButton.addEventListener('click', () => {
        try {
          if (isJSON) {
            JSON.parse(textarea.value);
          }
          localStorage.setItem(key, textarea.value);
          this.logMessage(`Элемент "${key}" успешно обновлен`, 'success');
          document.getElementById('storage-edit-entry')?.remove();
          this.showLocalStorageManager();
        } catch (e) {
          this.logMessage(`Ошибка сохранения: ${e.message}`, 'error');
        }
      });
      if (isJSON) {
        actions.appendChild(formatButton);
      }
      actions.appendChild(saveButton);
      editContainer.appendChild(actions);
      const logEntry = document.createElement('div');
      logEntry.id = 'storage-edit-entry';
      logEntry.className = 'dev-log-entry';
      logEntry.style.padding = '10px';
      const timestamp = new Date().toLocaleTimeString();
      logEntry.innerHTML = `
        <div class="dev-log-entry-header">
          <span class="dev-log-message info">Редактирование элемента LocalStorage</span>
          <span class="dev-log-timestamp">${timestamp}</span>
        </div>
        <div style="margin-top: 10px;" id="storage-edit-container">
          ${editContainer.outerHTML}
        </div>
      `;
      const logsContainer = document.getElementById('dev-panel-logs');
      if (logsContainer) {
        logsContainer.prepend(logEntry);
        document.getElementById('close-storage-edit').addEventListener('click', () => {
          logEntry.remove();
        });
        logEntry.scrollIntoView({ behavior: 'smooth' });
      }
    }

    calculateLocalStorageSize() {
      let total = 0;
      Object.keys(localStorage).forEach(key => {
        const value = localStorage.getItem(key);
        total += (key.length + value.length) * 2;
      });
      return (total / 1024).toFixed(2);
    }

    escapeHtml(text) {
      return text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    analyzeAndDisplayCourses() {
      if (!window.courseManager || !window.courseManager.courses) {
        this.logMessage('Данные курсов не загружены или недоступны', 'error');
        return;
      }
      this.showDebugInfo();
      const courses = window.courseManager.courses;
      const courseIds = Object.keys(courses);
      this.logMessage(`Анализ данных: загружено ${courseIds.length} курсов`, 'info');
      const detailedReport = document.createElement('div');
      detailedReport.className = 'dev-detailed-report';
      let totalLessons = 0;
      let totalWebhooks = 0;
      let webhookUrls = [];
      courseIds.forEach(courseId => {
        const course = courses[courseId];
        const courseSection = document.createElement('div');
        courseSection.className = 'dev-course-section';
        let courseInfo = `<h3 style="color: #56b6c2; margin: 10px 0;">Курс: ${course.title || courseId}</h3>`;
        if (course.redirectUrl) {
          courseInfo += `<div><span style="color: #d19a66;">Редирект URL:</span> ${course.redirectUrl}</div>`;
        }
        let daysList = '';
        let lessonCount = 0;
        let courseWebhooks = 0;
        if (course.days && Array.isArray(course.days)) {
          course.days.forEach((day, dayIndex) => {
            daysList += `<div style="margin-top: 8px;"><span style="color: #e5c07b;">День ${day.id}:</span> ${day.title || 'Без названия'}</div>`;
            if (day.lessons && Array.isArray(day.lessons)) {
              daysList += `<ul style="margin-top: 2px; padding-left: 20px;">`;
              day.lessons.forEach((lesson, lessonIndex) => {
                lessonCount++;
                totalLessons++;
                let lessonInfo = `<li><span style="color: #98c379;">Урок ${lesson.id}:</span> ${lesson.title || 'Без названия'}`;
                if (lesson.contentSource) {
                  if (lesson.contentSource.type === 'webhook') {
                    lessonInfo += ` <span style="color: #61afef;">[вебхук]</span>`;
                    courseWebhooks++;
                    totalWebhooks++;
                    webhookUrls.push(lesson.contentSource.url);
                  } else if (lesson.contentSource.type === 'local') {
                    lessonInfo += ` <span style="color: #c678dd;">[локальный]</span>`;
                  } else if (lesson.contentSource.type === 'markdown') {
                    lessonInfo += ` <span style="color: #56b6c2;">[встроенный]</span>`;
                  }
                } else {
                  lessonInfo += ` <span style="color: #e06c75;">[нет источника]</span>`;
                }
                if (lesson.testSource) {
                  lessonInfo += ` <span style="color: #98c379;">[тест]</span>`;
                }
                if (lesson.audioSource) {
                  lessonInfo += ` <span style="color: #d19a66;">[аудио]</span>`;
                }
                lessonInfo += `</li>`;
                daysList += lessonInfo;
              });
              daysList += `</ul>`;
            } else {
              daysList += `<div style="color: #e06c75; padding-left: 15px;">Уроки не найдены</div>`;
            }
          });
        } else {
          daysList = `<div style="color: #e06c75;">Дни обучения не найдены</div>`;
        }
        let specialLessonsList = '';
        if (course.specialLessons && Array.isArray(course.specialLessons)) {
          specialLessonsList += `<div style="margin-top: 10px;"><span style="color: #c678dd;">Специальные уроки:</span></div>`;
          specialLessonsList += `<ul style="margin-top: 2px; padding-left: 20px;">`;
          course.specialLessons.forEach((lesson, lessonIndex) => {
            lessonCount++;
            totalLessons++;
            let lessonInfo = `<li><span style="color: #98c379;">Урок ${lesson.id}:</span> ${lesson.title || 'Без названия'}`;
            if (lesson.contentSource) {
              if (lesson.contentSource.type === 'webhook') {
                lessonInfo += ` <span style="color: #61afef;">[вебхук]</span>`;
                courseWebhooks++;
                totalWebhooks++;
                webhookUrls.push(lesson.contentSource.url);
              } else if (lesson.contentSource.type === 'local') {
                lessonInfo += ` <span style="color: #c678dd;">[локальный]</span>`;
              } else if (lesson.contentSource.type === 'markdown') {
                lessonInfo += ` <span style="color: #56b6c2;">[встроенный]</span>`;
              }
            } else {
              lessonInfo += ` <span style="color: #e06c75;">[нет источника]</span>`;
            }
            if (lesson.testSource) {
              lessonInfo += ` <span style="color: #98c379;">[тест]</span>`;
            }
            if (lesson.audioSource) {
              lessonInfo += ` <span style="color: #d19a66;">[аудио]</span>`;
            }
            lessonInfo += `</li>`;
            specialLessonsList += lessonInfo;
          });
          specialLessonsList += `</ul>`;
        }
        let noDayLessonsList = '';
        if (course.noDayLessons && Array.isArray(course.noDayLessons)) {
          noDayLessonsList += `<div style="margin-top: 10px;"><span style="color: #c678dd;">Уроки без дней:</span></div>`;
          noDayLessonsList += `<ul style="margin-top: 2px; padding-left: 20px;">`;
          course.noDayLessons.forEach((lesson, lessonIndex) => {
            lessonCount++;
            totalLessons++;
            let lessonInfo = `<li><span style="color: #98c379;">Урок ${lesson.id}:</span> ${lesson.title || 'Без названия'}`;
            if (lesson.contentSource) {
              if (lesson.contentSource.type === 'webhook') {
                lessonInfo += ` <span style="color: #61afef;">[вебхук]</span>`;
                courseWebhooks++;
                totalWebhooks++;
                webhookUrls.push(lesson.contentSource.url);
              } else if (lesson.contentSource.type === 'local') {
                lessonInfo += ` <span style="color: #c678dd;">[локальный]</span>`;
              } else if (lesson.contentSource.type === 'markdown') {
                lessonInfo += ` <span style="color: #56b6c2;">[встроенный]</span>`;
              }
            } else {
              lessonInfo += ` <span style="color: #e06c75;">[нет источника]</span>`;
            }
            if (lesson.testSource) {
              lessonInfo += ` <span style="color: #98c379;">[тест]</span>`;
            }
            if (lesson.audioSource) {
              lessonInfo += ` <span style="color: #d19a66;">[аудио]</span>`;
            }
            lessonInfo += `</li>`;
            noDayLessonsList += lessonInfo;
          });
          noDayLessonsList += `</ul>`;
        }
        courseInfo += `<div><span style="color: #d19a66;">Всего уроков:</span> ${lessonCount}</div>`;
        courseInfo += `<div><span style="color: #d19a66;">Уроков с вебхуками:</span> ${courseWebhooks}</div>`;
        courseInfo += daysList;
        courseInfo += specialLessonsList;
        courseInfo += noDayLessonsList;
        courseSection.innerHTML = courseInfo;
        detailedReport.appendChild(courseSection);
        if (courseIds.indexOf(courseId) < courseIds.length - 1) {
          const divider = document.createElement('div');
          divider.style.height = '1px';
          divider.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
          divider.style.margin = '15px 0';
          detailedReport.appendChild(divider);
        }
      });
      const testWebhooksButton = document.createElement('button');
      testWebhooksButton.innerText = 'Проверить вебхуки';
      testWebhooksButton.style.backgroundColor = '#007bff';
      testWebhooksButton.style.color = 'white';
      testWebhooksButton.style.border = 'none';
      testWebhooksButton.style.padding = '8px 15px';
      testWebhooksButton.style.borderRadius = '4px';
      testWebhooksButton.style.cursor = 'pointer';
      testWebhooksButton.style.margin = '10px 0';
      testWebhooksButton.onclick = async () => {
        if (!webhookUrls || webhookUrls.length === 0) {
          this.logMessage('Нет доступных вебхуков для проверки', 'warning');
          return;
        }
        const webhooksToTest = webhookUrls.slice(0, 3);
        this.logMessage(`Начинаем проверку ${webhooksToTest.length} вебхуков...`, 'info');
        for (let i = 0; i < webhooksToTest.length; i++) {
          const url = webhooksToTest[i];
          this.logMessage(`Проверка вебхука ${i+1}/${webhooksToTest.length}: ${url}`, 'info');
          try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000);
            const response = await fetch(url, {
              method: 'GET',
              headers: {
                'Accept': 'text/plain, text/markdown, text/html, application/json, */*',
                'Cache-Control': 'no-cache'
              },
              mode: 'cors',
              cache: 'no-store',
              signal: controller.signal
            });
            clearTimeout(timeoutId);
            if (response.ok) {
              const contentType = response.headers.get('content-type') || '';
              const text = await response.text();
              this.logMessage(`Вебхук ${i+1} ответил успешно! Статус: ${response.status}, Content-Type: ${contentType}, Размер: ${text.length} байт`, 'success');
            } else {
              this.logMessage(`Вебхук ${i+1} вернул ошибку: HTTP ${response.status}`, 'error');
            }
          } catch (error) {
            this.logMessage(`Вебхук ${i+1} недоступен: ${error.message}`, 'error');
          }
        }
      };
      const summaryInfo = document.createElement('div');
      summaryInfo.className = 'dev-summary-info';
      summaryInfo.style.backgroundColor = 'rgba(0, 0, 0, 0.2)';
      summaryInfo.style.padding = '10px';
      summaryInfo.style.borderRadius = '4px';
      summaryInfo.style.marginBottom = '15px';
      summaryInfo.appendChild(testWebhooksButton);
      summaryInfo.innerHTML = `
        <div style="font-weight: bold; color: #56b6c2; margin-bottom: 5px;">Сводная информация:</div>
        <div><span style="color: #d19a66;">Всего курсов:</span> ${courseIds.length}</div>
        <div><span style="color: #d19a66;">Всего уроков:</span> ${totalLessons}</div>
        <div><span style="color: #d19a66;">Уроков с вебхуками:</span> ${totalWebhooks}</div>
      `;
      if (webhookUrls.length > 0) {
        let webhookList = `<div style="margin-top: 5px;"><span style="color: #d19a66;">Используемые URL вебхуков:</span></div><ul style="margin-top: 2px; padding-left: 20px;">`;
        const uniqueWebhooks = [...new Set(webhookUrls)];
        uniqueWebhooks.forEach(url => {
          const count = webhookUrls.filter(u => u === url).length;
          webhookList += `<li style="color: #61afef; word-break: break-all;">${url} <span style="color: #98c379;">(используется ${count} раз)</span></li>`;
        });
        webhookList += `</ul>`;
        summaryInfo.innerHTML += webhookList;
      }
      const webhookSettingsStr = localStorage.getItem('webhookSettings');
      if (webhookSettingsStr) {
        try {
          const webhookSettings = JSON.parse(webhookSettingsStr);
          let settingsInfo = `<div style="margin-top: 10px;"><span style="color: #d19a66;">Настройки вебхуков:</span></div><ul style="margin-top: 2px; padding-left: 20px;">`;
          if (webhookSettings.importUrl) {
            settingsInfo += `<li><span style="color: #98c379;">URL импорта:</span> <span style="color: #61afef; word-break: break-all;">${webhookSettings.importUrl}</span></li>`;
          }
          if (webhookSettings.exportUrl) {
            settingsInfo += `<li><span style="color: #98c379;">URL экспорта:</span> <span style="color: #61afef; word-break: break-all;">${webhookSettings.exportUrl}</span></li>`;
          }
          if (webhookSettings.contentWebhookUrl) {
            settingsInfo += `<li><span style="color: #98c379;">URL контента:</span> <span style="color: #61afef; word-break: break-all;">${webhookSettings.contentWebhookUrl}</span></li>`;
          }
          if (webhookSettings.testWebhookUrl) {
            settingsInfo += `<li><span style="color: #98c379;">URL тестов:</span> <span style="color: #61afef; word-break: break-all;">${webhookSettings.testWebhookUrl}</span></li>`;
          }
          settingsInfo += `</ul>`;
          summaryInfo.innerHTML += settingsInfo;
        } catch (e) {
          this.logMessage(`Ошибка при парсинге настроек вебхуков: ${e.message}`, 'error');
        }
      }
      const backupTimestamp = localStorage.getItem('coursesBackupTimestamp');
      if (backupTimestamp) {
        const date = new Date(backupTimestamp);
        const formattedDate = date.toLocaleString();
        summaryInfo.innerHTML += `<div style="margin-top: 5px;"><span style="color: #d19a66;">Последний бэкап:</span> ${formattedDate}</div>`;
      }
      detailedReport.insertBefore(summaryInfo, detailedReport.firstChild);
      const logEntry = document.createElement('div');
      logEntry.className = 'dev-log-entry';
      logEntry.style.padding = '10px';
      const timestamp = new Date().toLocaleTimeString();
      logEntry.innerHTML = `
        <div class="dev-log-entry-header">
          <span class="dev-log-message info">Подробный анализ данных курсов и вебхуков</span>
          <span class="dev-log-timestamp">${timestamp}</span>
        </div>
        <div style="margin-top: 10px;">
          ${detailedReport.outerHTML}
        </div>
      `;
      const logsContainer = document.getElementById('dev-panel-logs');
      if (logsContainer) {
        logsContainer.prepend(logEntry);
        logEntry.scrollIntoView({ behavior: 'smooth' });
      }
      console.log(`🔧 [DevMode] Подробный анализ данных курсов создан (${totalLessons} уроков, ${totalWebhooks} вебхуков)`);
    }
  }

  // Создаем глобальный экземпляр
  const devMode = new DevMode();
  document.addEventListener('DOMContentLoaded', () => {
    if (!document.querySelector('link[href*="font-awesome"]')) {
      const fontAwesome = document.createElement('link');
      fontAwesome.rel = 'stylesheet';
      fontAwesome.href = 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css';
      document.head.appendChild(fontAwesome);
    }
    devMode.initialize();
  });
  window.devMode = devMode;
  window.devMode = devMode;
  // ==================== END DEV MODE CODE ====================


  // ==================== BEGIN ADMIN CODE ====================
  /**
   * Административный модуль для управления курсами
   * 
   * Позволяет:
   * - Просматривать текущую структуру курсов
   * - Добавлять новые уроки
   * - Редактировать существующие уроки
   * - Управлять тестами
   * - Управлять заданиями
   */
  // import courseManager from './courseManager.js';
  const adminPanel = {
    show() {
      const adminInterface = window.adminInterface;
      if (adminInterface) {
        adminInterface.show();
      } else {
        console.error('Административный интерфейс не инициализирован!');
      }
    },
    hide() {
      const adminInterface = window.adminInterface;
      if (adminInterface) {
        adminInterface.hide();
      } else {
        console.error('Административный интерфейс не инициализирован!');
      }
    },
    init() {
      document.addEventListener('keydown', (e) => {
        if (e.altKey && e.shiftKey && e.key === 'A') {
          this.show();
        }
      });
      console.log('Админ-панель доступна по Alt+Shift+A');
      this.addUIControlsStyles();
      this.addUIToggleButton();
    },
    addUIControlsStyles() {
      const style = document.createElement('style');
      style.textContent = `
        .ui-controls-container {
          display: inline-block;
          margin-left: 10px;
        }
        .ui-controls-toggle {
          background-color: rgba(52, 152, 219, 0.8);
          color: white;
          border: none;
          border-radius: 4px;
          padding: 8px 12px;
          cursor: pointer;
          font-size: 14px;
          display: flex;
          align-items: center;
          transition: all 0.3s ease;
        }
        .ui-controls-toggle i {
          margin-right: 5px;
        }
        .ui-controls-toggle:hover {
          background-color: rgba(52, 152, 219, 1);
        }
        .ui-controls-toggle.controls-hidden {
          background-color: rgba(231, 76, 60, 0.8);
        }
        .ui-controls-toggle.controls-hidden:hover {
          background-color: rgba(231, 76, 60, 1);
        }
        .admin-toggle-hidden, .dev-mode-toggle-hidden {
          display: none !important;
        }
        @media (max-width: 768px) {
          .ui-controls-toggle span {
            display: none;
          }
          .ui-controls-toggle i {
            margin-right: 0;
          }
          .ui-controls-toggle {
            padding: 8px;
          }
        }
        .admin-header-actions {
          display: flex;
          align-items: center;
        }
      `;
      document.head.appendChild(style);
    },
    addUIToggleButton() {
      const toggleContainer = document.createElement('div');
      toggleContainer.id = 'ui-controls-container';
      toggleContainer.className = 'ui-controls-container';
      const toggleButton = document.createElement('button');
      toggleButton.id = 'ui-controls-toggle';
      toggleButton.className = 'ui-controls-toggle';
      toggleButton.innerHTML = '<i class="fas fa-eye-slash"></i> <span>Управление интерфейсом</span>';
      toggleButton.title = 'Скрыть/показать кнопки управления';
      toggleContainer.appendChild(toggleButton);
      toggleButton.addEventListener('click', function() {
        const adminToggle = document.getElementById('admin-toggle');
        const devModeToggle = document.getElementById('dev-mode-toggle');
        if (adminToggle) {
          adminToggle.classList.toggle('admin-toggle-hidden');
        }
        if (devModeToggle) {
          devModeToggle.classList.toggle('dev-mode-toggle-hidden');
        }
        if ((adminToggle && adminToggle.classList.contains('admin-toggle-hidden')) || 
            (devModeToggle && devModeToggle.classList.contains('dev-mode-toggle-hidden'))) {
          toggleButton.innerHTML = '<i class="fas fa-eye"></i> <span>Показать управление</span>';
          toggleButton.classList.add('controls-hidden');
          toggleButton.title = 'Показать кнопки управления';
        } else {
          toggleButton.innerHTML = '<i class="fas fa-eye-slash"></i> <span>Скрыть управление</span>';
          toggleButton.classList.remove('controls-hidden');
          toggleButton.title = 'Скрыть кнопки управления';
        }
      });
      const addButtonToAdminPanel = () => {
        const adminHeaderActions = document.querySelector('.admin-header-actions');
        if (adminHeaderActions) {
          adminHeaderActions.appendChild(toggleContainer);
          console.log('Кнопка управления интерфейсом добавлена в админ-панель');
        } else {
          document.body.appendChild(toggleContainer);
          console.log('Не найден контейнер admin-header-actions, добавляем кнопку в body');
        }
      };
      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(addButtonToAdminPanel, 500);
      } else {
        window.addEventListener('load', () => {
          setTimeout(addButtonToAdminPanel, 500);
        });
      }
    }
  };

  document.addEventListener('DOMContentLoaded', () => {
    adminPanel.init();
    window.setTimeout(() => {
      const adminPanelButton = document.querySelector('[onclick="openAdminPanel()"]');
      if (adminPanelButton) {
        adminPanelButton.id = 'admin-toggle';
      }
    }, 500);
  });
  window.adminPanel = adminPanel;
  window.openAdminPanel = function() {
    adminPanel.show();
  };
  // ==================== END ADMIN CODE ====================
  // ==================== BEGIN APP CODE ====================
  // Основной модуль приложения
  // Предполагается, что courseManager, devMode и (при наличии) adminInterface уже определены

  // Контейнеры для разных секций
  const homeContainer = document.getElementById('home');
  const guideContainer = document.getElementById('guide');
  const daySelectionContainer = document.getElementById('day-selection');
  const taskSelectionContainer = document.getElementById('task-selection');
  const dayHeader = document.getElementById('day-header');
  const taskButtonsDiv = document.getElementById('task-buttons');
  const professionSelect = document.getElementById('profession-select');
  const guideTitle = document.getElementById('guide-title');
  const loadingSpinner = document.getElementById('loading-spinner');
  const markdownContent = document.getElementById('markdown-content');
  const testButton = document.getElementById('test-button');

  // Функция обновления статуса загрузки
  function updateLoadingStatus(message, isError = false) {
    const statusElement = document.querySelector('.loading-status');
    if (statusElement) {
      statusElement.textContent = message;
      if (isError) {
        statusElement.style.color = '#ff5555';
        statusElement.style.fontWeight = 'bold';
      } else {
        statusElement.style.color = '';
        statusElement.style.fontWeight = '';
      }
    }
    console.log('Статус загрузки:', message);
  }

  // Функция для автоматического импорта настроек вебхуков
  async function autoImportWebhooks() {
    console.log('Проверка наличия настроек вебхуков...');
    const webhookSettingsStr = localStorage.getItem('webhookSettings');
    if (!webhookSettingsStr) {
      console.log('Настройки вебхуков не найдены, устанавливаем значения по умолчанию');
      const defaultWebhookSettings = {
        exportUrl: 'https://auto.crm-s.com/webhook/SaveWebhooks',
        importUrl: 'https://auto.crm-s.com/webhook/OnboardingJSON',
        getUrl: 'https://auto.crm-s.com/webhook/GetOnboardingHooks'
      };
      localStorage.setItem('webhookSettings', JSON.stringify(defaultWebhookSettings));
      localStorage.setItem('adminExportWebhook', defaultWebhookSettings.exportUrl);
      localStorage.setItem('adminImportWebhook', defaultWebhookSettings.importUrl);
      localStorage.setItem('adminGetWebhook', defaultWebhookSettings.getUrl);
      console.log('Установлены настройки вебхуков по умолчанию:');
      console.log('- Import URL:', defaultWebhookSettings.importUrl);
      console.log('- Export URL:', defaultWebhookSettings.exportUrl);
      console.log('- Get URL:', defaultWebhookSettings.getUrl);
      if (window.adminInterface && typeof window.adminInterface.loadWebhookSettings === 'function') {
        window.adminInterface.loadWebhookSettings();
      }
      await importWebhooksFromServer(defaultWebhookSettings.getUrl);
      return defaultWebhookSettings;
    }
    try {
      const settings = JSON.parse(webhookSettingsStr);
      let updated = false;
      if (!settings.importUrl) {
        settings.importUrl = 'https://auto.crm-s.com/webhook/OnboardingJSON';
        localStorage.setItem('adminImportWebhook', settings.importUrl);
        updated = true;
      }
      if (!settings.exportUrl) {
        settings.exportUrl = 'https://auto.crm-s.com/webhook/SaveWebhooks';
        localStorage.setItem('adminExportWebhook', settings.exportUrl);
        updated = true;
      }
      if (!settings.getUrl) {
        settings.getUrl = 'https://auto.crm-s.com/webhook-test/GetOnboardingHooks';
        localStorage.setItem('adminGetWebhook', settings.getUrl);
        updated = true;
      }
      if (updated) {
        localStorage.setItem('webhookSettings', JSON.stringify(settings));
        console.log('Обновлены недостающие настройки вебхуков');
      } else {
        console.log('Найдены все необходимые настройки вебхуков');
      }
      await importWebhooksFromServer(settings.getUrl);
      return settings;
    } catch (e) {
      console.error('Ошибка при проверке настроек вебхуков:', e);
      return null;
    }
  }

  // Функция для импорта вебхуков с сервера
  async function importWebhooksFromServer(url) {
    if (!url) {
      console.log('URL для получения вебхуков не указан, пропускаем импорт');
      return;
    }
    console.log(`Автоматический импорт вебхуков с URL: ${url}`);
    updateLoadingStatus('Получение настроек вебхуков...');
    try {
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Accept': 'application/json, text/plain, */*',
          'Cache-Control': 'no-cache'
        },
        cache: 'no-store'
      });
      if (!response.ok) {
        throw new Error(`HTTP ошибка! Статус: ${response.status}`);
      }
      const responseText = await response.text();
      console.log(`Получен ответ с вебхуками (${responseText.length} символов)`);
      try {
        const jsonData = JSON.parse(responseText);
        processWebhooksData(jsonData);
        updateLoadingStatus('Настройки вебхуков успешно импортированы');
        return true;
      } catch (jsonError) {
        console.error('Ошибка при парсинге JSON с вебхуками:', jsonError);
        const jsonRegex = /{[\s\S]*}/;
        const match = responseText.match(jsonRegex);
        if (match && match[0]) {
          try {
            const extractedData = JSON.parse(match[0]);
            processWebhooksData(extractedData);
            updateLoadingStatus('Настройки вебхуков успешно импортированы из текста');
            return true;
          } catch (e) {
            console.error('Ошибка при извлечении JSON из текста:', e);
          }
        }
        const urlRegex = /(https?:\/\/[^\s"]+)/g;
        const urls = responseText.match(urlRegex);
        if (urls && urls.length > 0) {
          console.log(`Найдено ${urls.length} URL в ответе`);
          if (urls.length > 0) {
            localStorage.setItem('adminImportWebhook', urls[0]);
            console.log(`Установлен URL импорта из текста: ${urls[0]}`);
            const settings = JSON.parse(localStorage.getItem('webhookSettings') || '{}');
            settings.importUrl = urls[0];
            localStorage.setItem('webhookSettings', JSON.stringify(settings));
            updateLoadingStatus('URL импорта установлен из текстового ответа');
            return true;
          }
        }
      }
    } catch (error) {
      console.error('Ошибка при импорте вебхуков:', error);
      updateLoadingStatus(`Ошибка при импорте вебхуков: ${error.message}`);
      return false;
    }
  }

  // Функция для обработки полученных данных вебхуков
  function processWebhooksData(data) {
    try {
      console.log('Обработка данных вебхуков:', Object.keys(data));
      let updated = false;
      let settings = JSON.parse(localStorage.getItem('webhookSettings') || '{}');
      if (data.webhooks && Array.isArray(data.webhooks)) {
        console.log(`Найдено ${data.webhooks.length} вебхуков в массиве webhooks`);
        for (const webhook of data.webhooks) {
          if (webhook.url) {
            if (webhook.type === 'export' || webhook.id === 'export_courses_hook') {
              settings.exportUrl = webhook.url;
              localStorage.setItem('adminExportWebhook', webhook.url);
              console.log(`Установлен URL экспорта: ${webhook.url}`);
              updated = true;
            } else if (webhook.type === 'import' || webhook.id === 'import_courses_hook') {
              settings.importUrl = webhook.url;
              localStorage.setItem('adminImportWebhook', webhook.url);
              localStorage.setItem('importWebhookUrl', webhook.url);
              console.log(`Установлен URL импорта: ${webhook.url}`);
              updated = true;
            } else if (webhook.type === 'notification' || webhook.id === 'notify_updates_hook') {
              settings.getUrl = webhook.url;
              localStorage.setItem('adminGetWebhook', webhook.url);
              console.log(`Установлен URL получения вебхуков: ${webhook.url}`);
              updated = true;
            }
          }
        }
      }
      if (data.exportUrl) {
        settings.exportUrl = data.exportUrl;
        localStorage.setItem('adminExportWebhook', data.exportUrl);
        console.log(`Установлен URL экспорта: ${data.exportUrl}`);
        updated = true;
      }
      if (data.importUrl) {
        settings.importUrl = data.importUrl;
        localStorage.setItem('adminImportWebhook', data.importUrl);
        localStorage.setItem('importWebhookUrl', data.importUrl);
        console.log(`Установлен URL импорта: ${data.importUrl}`);
        updated = true;
      }
      if (data.getWebhooksUrl) {
        settings.getUrl = data.getWebhooksUrl;
        localStorage.setItem('adminGetWebhook', data.getWebhooksUrl);
        console.log(`Установлен URL получения вебхуков: ${data.getWebhooksUrl}`);
        updated = true;
      }
      const foundUrls = findUrlsInObject(data);
      if (foundUrls.length > 0) {
        console.log(`Найдено ${foundUrls.length} URL-адресов в данных`);
        foundUrls.forEach(urlInfo => {
          if (urlInfo.type === 'export') {
            settings.exportUrl = urlInfo.url;
            localStorage.setItem('adminExportWebhook', urlInfo.url);
            console.log(`Автоматически установлен URL экспорта: ${urlInfo.url}`);
            updated = true;
          } else if (urlInfo.type === 'import') {
            settings.importUrl = urlInfo.url;
            localStorage.setItem('adminImportWebhook', urlInfo.url);
            localStorage.setItem('importWebhookUrl', urlInfo.url);
            console.log(`Автоматически установлен URL импорта: ${urlInfo.url}`);
            updated = true;
          } else if (urlInfo.type === 'get') {
            settings.getUrl = urlInfo.url;
            localStorage.setItem('adminGetWebhook', urlInfo.url);
            console.log(`Автоматически установлен URL получения вебхуков: ${urlInfo.url}`);
            updated = true;
          }
        });
      }
      if (updated) {
        localStorage.setItem('webhookSettings', JSON.stringify(settings));
        console.log('Настройки вебхуков обновлены из полученных данных');
        if (window.adminInterface && typeof window.adminInterface.loadWebhookSettings === 'function') {
          window.adminInterface.loadWebhookSettings();
        }
      }
    } catch (error) {
      console.error('Ошибка при обработке данных вебхуков:', error);
    }
  }

  // Рекурсивный поиск URL в объекте
  function findUrlsInObject(obj, path = '', results = []) {
    if (!obj || typeof obj !== 'object') return results;
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        const value = obj[key];
        const currentPath = path ? `${path}.${key}` : key;
        if (typeof value === 'string' && isValidUrl(value)) {
          let type = 'unknown';
          if (key.toLowerCase().includes('export') || value.toLowerCase().includes('export') ||
              key.toLowerCase().includes('save') || value.toLowerCase().includes('save')) {
            type = 'export';
          } else if (key.toLowerCase().includes('import') || value.toLowerCase().includes('import') ||
                    key.toLowerCase().includes('get') || value.toLowerCase().includes('get')) {
            type = 'import';
          } else if (key.toLowerCase().includes('webhook') || value.toLowerCase().includes('webhook') ||
                    key.toLowerCase().includes('notification') || value.toLowerCase().includes('notification')) {
            type = 'get';
          }
          results.push({
            url: value,
            path: currentPath,
            type: type
          });
        } else if (typeof value === 'object' && value !== null) {
          findUrlsInObject(value, currentPath, results);
        }
      }
    }
    return results;
  }

  // Проверка валидности URL
  function isValidUrl(url) {
    try {
      new URL(url);
      return true;
    } catch (e) {
      return false;
    }
  }

  // Принудительная синхронизация с облаком (возвращает Promise)
  async function forceSyncWithCloud() {
    return new Promise(async (resolve, reject) => {
      console.log('Принудительная синхронизация с облаком...');
      updateLoadingStatus('Поиск URL для импорта данных...');
      await autoImportWebhooks();
      const webhookSettingsStr = localStorage.getItem('webhookSettings');
      let importWebhookUrl = null;
      if (webhookSettingsStr) {
        try {
          const webhookSettings = JSON.parse(webhookSettingsStr);
          if (webhookSettings.importUrl) {
            importWebhookUrl = webhookSettings.importUrl;
            console.log(`Найден URL импорта в настройках вебхуков: ${importWebhookUrl}`);
            updateLoadingStatus(`Найден URL импорта данных в настройках вебхуков`);
          }
        } catch (e) {
          console.error('Ошибка при парсинге настроек вебхуков:', e);
          updateLoadingStatus('Ошибка при чтении настроек вебхуков');
        }
      }
      if (!importWebhookUrl) {
        importWebhookUrl = localStorage.getItem('adminImportWebhook') || localStorage.getItem('importWebhookUrl') || localStorage.getItem('testImportUrl');
      }
      if (importWebhookUrl) {
        if (window.devMode && window.devMode.enabled) {
          console.log('🔧 [DevMode] Выполняется принудительная синхронизация с облаком');
          console.log(`🔧 [DevMode] URL для импорта: ${importWebhookUrl}`);
        }
        try {
          updateLoadingStatus(`Отправка запроса на ${importWebhookUrl.split('/').slice(-1)[0]}`);
          console.log(`Выполняется импорт данных с URL: ${importWebhookUrl}`);
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 15000);
          try {
            const response = await fetch(importWebhookUrl, {
              method: 'GET',
              headers: {
                'Accept': 'application/json, text/plain, */*',
                'Content-Type': 'application/json',
                'Cache-Control': 'no-cache',
                'Pragma': 'no-cache'
              },
              cache: 'no-store',
              mode: 'cors',
              credentials: 'omit',
              signal: controller.signal
            });
            clearTimeout(timeoutId);
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }
            updateLoadingStatus('Получен ответ от сервера, обработка данных...');
            const responseText = await response.text();
            console.log(`Получен ответ от сервера, размер: ${responseText.length} байт`);
            try {
              let importData;
              console.log('Raw response:', JSON.stringify(responseText));
              if (!responseText || responseText.length < 10) {
                if (responseText && (responseText.trim() === 'Accepted' || responseText.trim() === 'OK' || responseText.trim().startsWith('Success'))) {
                  console.log('Получен положительный текстовый ответ от сервера:', responseText.trim());
                  return resolve({success: true, updated: false, message: `Сервер ответил: ${responseText.trim()}`});
                }
              }
              try {
                updateLoadingStatus('Обработка данных в формате JSON...');
                try {
                  importData = JSON.parse(responseText.trim());
                  console.log('Успешно распарсен JSON из полного ответа');
                } catch (initialParseError) {
                  const trimmedText = responseText.trim();
                  if (trimmedText.startsWith('{') || trimmedText.startsWith('[')) {
                    try {
                      importData = JSON.parse(trimmedText);
                      console.log('Успешно распарсен JSON из ответа после обрезки');
                    } catch (e) {
                      throw initialParseError;
                    }
                  } else {
                    throw new Error('Ответ не содержит JSON напрямую, поиск JSON внутри ответа');
                  }
                }
              } catch (jsonError) {
                updateLoadingStatus('Поиск JSON данных в ответе...');
                console.log('Не удалось распарсить ответ как JSON, ищем JSON в тексте:', jsonError.message);
                const jsonRegex = /{[\s\S]*}/;
                const match = responseText.match(jsonRegex);
                if (match && match[0]) {
                  try {
                    importData = JSON.parse(match[0]);
                    console.log('Найден и распарсен JSON в тексте ответа');
                  } catch (nestedError) {
                    console.error('Ошибка при парсинге найденного JSON:', nestedError.message);
                    if (responseText.length < 100) {
                      console.log('Получен короткий текстовый ответ, считаем синхронизацию успешной');
                      return resolve({success: true, updated: false, message: `Сервер ответил: ${responseText.substring(0, 50)}`});
                    }
                    throw new Error('Не удалось распарсить найденный JSON');
                  }
                } else {
                  if (responseText.trim().length > 0 && responseText.trim().length < 100) {
                    console.log('Получен текстовый ответ без JSON, считаем синхронизацию успешной');
                    return resolve({success: true, updated: false, message: `Сервер ответил: ${responseText.substring(0, 50)}`});
                  }
                  throw new Error('Не удалось извлечь JSON из ответа');
                }
              }
              let coursesData = null;
              if (importData.courses) {
                coursesData = importData.courses;
                console.log('Найдены курсы в поле courses');
              } else if (importData.data) {
                if (typeof importData.data === 'object') {
                  coursesData = importData.data;
                  console.log('Найдены курсы в поле data (объект)');
                } else if (typeof importData.data === 'string') {
                  try {
                    const parsedData = JSON.parse(importData.data);
                    coursesData = parsedData.courses || parsedData;
                    console.log('Найдены курсы в поле data (JSON строка)');
                  } catch (e) {
                    console.log(`Не удалось распарсить JSON в поле data: ${e.message}`);
                  }
                }
              } else if (importData.content && typeof importData.content === 'object') {
                coursesData = importData.content;
                console.log('Найдены курсы в поле content (объект)');
              } else if (typeof importData === 'object') {
                const hasValidStructure = Object.values(importData).some(value => {
                  return value && typeof value === 'object' && 
                        (value.days || value.specialLessons || value.title || value.redirectUrl || value.noDayLessons);
                });
                if (hasValidStructure) {
                  coursesData = importData;
                  console.log('Корневой объект используется как структура курсов');
                }
              }
              if (coursesData) {
                const isValid = validateCoursesStructure(coursesData);
                if (!isValid) {
                  console.error('Неверная структура данных курсов');
                  return resolve({success: false, error: 'Неверная структура данных'});
                }
                const forceUpdate = !courseManager.courses;
                const currentCoursesJson = JSON.stringify(courseManager.courses || {});
                const newCoursesJson = JSON.stringify(coursesData);
                if (forceUpdate || currentCoursesJson !== newCoursesJson) {
                  console.log(forceUpdate 
                    ? 'Принудительное обновление данных курсов' 
                    : 'Обнаружены изменения данных, применяем обновления из облака');
                  if (courseManager.courses) {
                    localStorage.setItem('coursesBackup', currentCoursesJson);
                    localStorage.setItem('coursesBackupTimestamp', new Date().toISOString());
                  }
                  cacheWebhookUrls(coursesData);
                  updateLoadingStatus('Применение новой конфигурации курсов...');
                  applyCoursesConfig(coursesData);
                  console.log('Синхронизация с облаком успешно завершена, интерфейс обновлен');
                  updateLoadingStatus('Синхронизация завершена успешно');
                  return resolve({success: true, updated: true, data: coursesData});
                } else {
                  console.log('Данные актуальны, синхронизация не требуется');
                  updateLoadingStatus('Данные актуальны, синхронизация не требуется');
                  return resolve({success: true, updated: false});
                }
              } else {
                console.log('Не удалось найти данные о курсах в ответе');
                return resolve({success: false, error: 'Данные о курсах не найдены'});
              }
            } catch (fetchError) {
              clearTimeout(timeoutId);
              console.error('Ошибка при получении данных:', fetchError);
              updateLoadingStatus(`Ошибка при получении данных: ${fetchError.message}`);
              const backupDataStr = localStorage.getItem('coursesBackup');
              if (backupDataStr) {
                try {
                  console.log('Используем резервную копию из-за ошибки сети');
                  console.log('Резервная копия от:', localStorage.getItem('coursesBackupTimestamp'));
                  const backupData = JSON.parse(backupDataStr);
                  courseManager.courses = backupData;
                  return resolve({success: true, updated: false, fromBackup: true});
                } catch (backupError) {
                  console.error('Ошибка при загрузке резервной копии:', backupError);
                }
              }
              if (fetchError.name === 'AbortError') {
                return resolve({success: false, error: 'Таймаут запроса'});
              } else {
                return resolve({success: false, error: fetchError.message});
              }
            }
          } catch (e) {
            console.error('Ошибка при принудительной синхронизации:', e);
            updateLoadingStatus(`Ошибка синхронизации: ${e.message}`);
            const backupDataStr = localStorage.getItem('coursesBackup');
            if (backupDataStr) {
              try {
                const backupData = JSON.parse(backupDataStr);
                courseManager.courses = backupData;
                return resolve({success: true, updated: false, fromBackup: true});
              } catch (backupError) {
                console.error('Ошибка при загрузке резервной копии:', backupError);
                return reject(e);
              }
            } else {
              return reject(e);
            }
          }
        } else {
          console.log('URL вебхука для импорта не найден, проверяем резервную копию');
          const backupDataStr = localStorage.getItem('coursesBackup');
          if (backupDataStr) {
            try {
              console.log('URL импорта не найден, используем резервную копию');
              const backupData = JSON.parse(backupDataStr);
              courseManager.courses = backupData;
              return resolve({success: true, updated: false, fromBackup: true});
            } catch (backupError) {
              console.error('Ошибка при загрузке резервной копии:', backupError);
            }
          }
          updateLoadingStatus('URL вебхука для импорта не найден');
          return resolve({success: false, error: 'URL импорта не найден'});
        }
      } catch (error) {
        console.error('Ошибка при принудительной синхронизации с облаком:', error);
        if (error.name === 'AbortError') {
          console.error('Превышено время ожидания ответа от сервера (таймаут)');
          return resolve({success: false, error: 'Таймаут запроса'});
        }
        return resolve({success: false, error: error.message});
      }
    });
  }

  // Функция для валидации структуры данных курсов
  function validateCoursesStructure(coursesData) {
    if (!coursesData || typeof coursesData !== 'object') {
      return false;
    }
    const courseKeys = Object.keys(coursesData);
    return courseKeys.length > 0 && 
      courseKeys.some(key => {
        const course = coursesData[key];
        return course && typeof course === 'object' && 
               (course.days || course.specialLessons || course.redirectUrl || course.noDayLessons);
      });
  }

  // Функция для кеширования всех URL вебхуков из уроков
  function cacheWebhookUrls(coursesData) {
    const webhookUrls = {};
    Object.keys(coursesData).forEach(professionId => {
      const course = coursesData[professionId];
      if (course.days && Array.isArray(course.days)) {
        course.days.forEach(day => {
          if (day.lessons && Array.isArray(day.lessons)) {
            day.lessons.forEach(lesson => {
              if (lesson.contentSource && lesson.contentSource.type === 'webhook' && lesson.contentSource.url) {
                const key = `${professionId}_${day.id}_${lesson.id}`;
                webhookUrls[key] = lesson.contentSource.url;
              }
            });
          }
        });
      }
      if (course.specialLessons && Array.isArray(course.specialLessons)) {
        course.specialLessons.forEach(lesson => {
          if (lesson.contentSource && lesson.contentSource.type === 'webhook' && lesson.contentSource.url) {
            const key = `${professionId}_special_${lesson.id}`;
            webhookUrls[key] = lesson.contentSource.url;
          }
        });
      }
      if (course.noDayLessons && Array.isArray(course.noDayLessons)) {
        course.noDayLessons.forEach(lesson => {
          if (lesson.contentSource && lesson.contentSource.type === 'webhook' && lesson.contentSource.url) {
            const key = `${professionId}_noday_${lesson.id}`;
            webhookUrls[key] = lesson.contentSource.url;
          }
        });
      }
    });
    localStorage.setItem('webhookUrlsCache', JSON.stringify(webhookUrls));
    if (window.devMode && window.devMode.enabled) {
      console.log(`🔧 [DevMode] Кешировано ${Object.keys(webhookUrls).length} URL вебхуков для уроков`);
    }
  }

  // Функция для применения обновленной конфигурации курсов
  function applyCoursesConfig(coursesData) {
    console.log('Применение новой конфигурации курсов к приложению');
    if (window.devMode && window.devMode.enabled) {
      console.log('🔧 [DevMode] Применение новой конфигурации курсов к приложению');
    }
    const currentProfession = courseManager.currentProfession;
    const currentDayId = courseManager.currentDay ? courseManager.currentDay.id : null;
    const currentLessonId = courseManager.currentLesson ? courseManager.currentLesson.id : null;
    if (window.devMode && window.devMode.enabled) {
      let webhookCount = 0;
      Object.values(coursesData).forEach(course => {
        if (course.days && Array.isArray(course.days)) {
          course.days.forEach(day => {
            if (day.lessons && Array.isArray(day.lessons)) {
              day.lessons.forEach(lesson => {
                if (lesson.contentSource && lesson.contentSource.type === 'webhook') {
                  webhookCount++;
                  console.log(`🔧 [DevMode] Вебхук в уроке ${lesson.id}: ${lesson.contentSource.url}`);
                }
              });
            }
          });
        }
      });
      console.log(`🔧 [DevMode] Всего найдено ${webhookCount} вебхуков в уроках`);
    }
    courseManager.courses = coursesData;
    console.log('Уведомление подписчиков об обновлении курсов');
    courseManager.notifyCoursesUpdated();
    console.log('Обновление селектора профессий');
    updateProfessionSelector();
    if (!coursesData[currentProfession]) {
      const professions = Object.keys(coursesData);
      if (professions.length > 0) {
        const newProfession = professions[0];
        console.log(`Текущая профессия ${currentProfession} не найдена, переключаемся на ${newProfession}`);
        courseManager.switchProfession(newProfession);
      } else {
        console.error('Нет доступных профессий в новой конфигурации');
        return;
      }
    } else {
      console.log(`Переключаемся на профессию: ${currentProfession}`);
      courseManager.switchProfession(currentProfession);
    }
    console.log('Обновление списка дней');
    updateDaysList();
    if (currentDayId) {
      const dayFound = courseManager.selectDay(currentDayId);
      if (dayFound) {
        console.log(`Выбран день с ID: ${currentDayId}`);
        updateLessonsList();
        if (currentLessonId) {
          const lessonFound = courseManager.selectLesson(currentLessonId);
          if (lessonFound) {
            console.log(`Выбран урок с ID: ${currentLessonId}`);
            if (document.getElementById('guide').classList.contains('hidden') === false) {
              console.log('Перезагрузка контента текущего урока');
              loadLessonContent();
            }
          } else {
            console.log(`Урок с ID ${currentLessonId} не найден в обновленной конфигурации`);
          }
        }
      } else {
        console.log(`День с ID ${currentDayId} не найден в обновленной конфигурации`);
      }
    }
    console.log('Данные курсов успешно обновлены из импортированного JSON');
    if (document.getElementById('home').classList.contains('hidden') === false) {
      console.log('Обновление домашней страницы');
      renderHomePage();
    }
  }

  // Функция для обновления селектора профессий
  function updateProfessionSelector() {
    const professionSelect = document.getElementById('profession-select');
    if (!professionSelect) return;
    const currentValue = professionSelect.value;
    const professions = courseManager.getProfessions();
    professionSelect.innerHTML = '';
    professions.forEach(professionId => {
      const course = courseManager.courses[professionId];
      const option = document.createElement('option');
      option.value = professionId;
      option.textContent = course.title || professionId;
      professionSelect.appendChild(option);
    });
    if (professions.includes(currentValue)) {
      professionSelect.value = currentValue;
    }
  }

  // Функция для обновления списка дней
  function updateDaysList() {
    const daySelectionContainer = document.getElementById('day-selection');
    if (!daySelectionContainer) return;
    let dayCardsContainer = daySelectionContainer.querySelector('.content-cards');
    if (!dayCardsContainer) {
      dayCardsContainer = document.createElement('div');
      dayCardsContainer.className = 'content-cards';
      daySelectionContainer.appendChild(dayCardsContainer);
    }
    dayCardsContainer.innerHTML = '';
    const daysTitle = document.createElement('h2');
    daysTitle.textContent = 'Выберите день обучения:';
    dayCardsContainer.appendChild(daysTitle);
    const days = courseManager.getDays();
    console.log(`Загружено ${days.length} дней для профессии ${courseManager.currentProfession}`);
    days.forEach(day => {
      const card = document.createElement('div');
      card.className = 'course-card';
      card.innerHTML = `
        <h3>${day.title || `День ${day.id}`}</h3>
        <p>${day.description || 'Нажмите, чтобы просмотреть уроки'}</p>
      `;
      card.onclick = () => selectDay(day.id);
      dayCardsContainer.appendChild(card);
    });
    if (days.length === 0) {
      const emptyMessage = document.createElement('p');
      emptyMessage.textContent = 'Для этой профессии еще не добавлены дни обучения.';
      dayCardsContainer.appendChild(emptyMessage);
    }
  }

  // Функция для обновления списка уроков
  function updateLessonsList() {
    if (!courseManager.currentDay) {
      console.log('Не выбран текущий день, невозможно обновить список уроков');
      return;
    }
    const taskButtonsDiv = document.getElementById('task-buttons');
    if (!taskButtonsDiv) {
      console.error('Не найден контейнер для кнопок уроков (task-buttons)');
      return;
    }
    taskButtonsDiv.innerHTML = '';
    try {
      const lessons = courseManager.getLessonsForCurrentDay();
      if (!lessons || !Array.isArray(lessons)) {
        console.error('Получен некорректный список уроков:', lessons);
        const errorMessage = document.createElement('p');
        errorMessage.textContent = 'Ошибка загрузки уроков. Попробуйте перезагрузить страницу.';
        errorMessage.className = 'error-message';
        errorMessage.style.color = '#ff5555';
        taskButtonsDiv.appendChild(errorMessage);
        return;
      }
      console.log(`Загружено ${lessons.length} уроков для дня ${courseManager.currentDay.id}`);
      if (lessons.length === 0) {
        const emptyMessage = document.createElement('p');
        emptyMessage.textContent = 'Для этого дня еще не добавлены уроки.';
        emptyMessage.className = 'empty-message';
        taskButtonsDiv.appendChild(emptyMessage);
        return;
      }
      lessons.forEach(lesson => {
        const btn = document.createElement('button');
        btn.innerText = lesson.title || `Урок ${lesson.id}`;
        btn.onclick = function() { selectLesson(lesson.id); };
        if (lesson.description) {
          const description = document.createElement('small');
          description.textContent = lesson.description;
          description.style.display = 'block';
          description.style.marginTop = '5px';
          description.style.color = '#666';
          btn.appendChild(description);
        }
        taskButtonsDiv.appendChild(btn);
      });
    } catch (error) {
      console.error('Ошибка при обновлении списка уроков:', error);
      const errorMessage = document.createElement('p');
      errorMessage.textContent = 'Произошла ошибка при загрузке уроков.';
      errorMessage.className = 'error-message';
      errorMessage.style.color = '#ff5555';
      taskButtonsDiv.appendChild(errorMessage);
    }
  }

  // Функция отображения домашней страницы
  function renderHomePage() {
    if (!courseManager.courses || Object.keys(courseManager.courses).length === 0) {
      console.error('Ошибка: данные курсов не загружены, невозможно отобразить домашнюю страницу');
      updateLoadingStatus('Ошибка: данные курсов не загружены', true);
      return;
    }
    console.log('Отображение домашней страницы с загруженными курсами:', Object.keys(courseManager.courses));
    updateProfessionSelector();
    if (courseManager.currentProfession) {
      updateDaysList();
      updateVocabularyButton();
    }
    showSection('home');
    daySelectionContainer.classList.remove('hidden');
    taskSelectionContainer.classList.add('hidden');
  }

  // Функция обработки смены профессии
  function handleProfessionChange() {
    const selectedProfession = professionSelect.value;
    if (courseManager.hasRedirect(selectedProfession)) {
      const redirectUrl = courseManager.getRedirectUrl(selectedProfession);
      if (redirectUrl) {
        console.log(`Перенаправление на внешний ресурс: ${redirectUrl}`);
        window.location.href = redirectUrl;
        return;
      }
    }
    console.log(`Переключение на профессию: ${selectedProfession}`);
    courseManager.switchProfession(selectedProfession);
    updateDaysList();
    courseManager.currentLesson = null;
    showSection('home');
    daySelectionContainer.classList.remove('hidden');
    taskSelectionContainer.classList.add('hidden');
    updateVocabularyButton();
  }

  // Функция выбора дня обучения
  window.selectDay = function(dayId) {
    const day = courseManager.selectDay(dayId);
    if (!day) {
      console.error(`День с ID ${dayId} не найден`);
      return;
    }
    dayHeader.innerText = day.title || `День ${day.id}`;
    daySelectionContainer.classList.add('hidden');
    taskSelectionContainer.classList.remove('hidden');
    updateLessonsList();
  };

  // Функция выбора урока
  window.selectLesson = function(lessonId) {
    const lesson = courseManager.selectLesson(lessonId);
    if (!lesson) {
      console.error(`Урок с ID ${lessonId} не найден`);
      alert(`Урок с ID ${lessonId} не найден. Пожалуйста, выберите другой урок.`);
      return;
    }
    console.log(`Выбран урок: ${lesson.title} (ID: ${lesson.id})`);
    if (lesson.contentSource) {
      console.log(`Источник контента: ${lesson.contentSource.type}`);
      if (lesson.contentSource.type === 'webhook') {
        console.log(`URL вебхука: ${lesson.contentSource.url}`);
        const cacheKey = `${courseManager.currentProfession}_${courseManager.currentDay ? courseManager.currentDay.id : 'special'}_${lesson.id}`;
        const cachedUrl = getCachedWebhookUrl(cacheKey);
        if (cachedUrl && cachedUrl !== lesson.contentSource.url) {
          console.log(`Обнаружено изменение URL вебхука для урока ${lesson.id}`);
          console.log(`Предыдущий URL: ${cachedUrl}`);
          console.log(`Новый URL: ${lesson.contentSource.url}`);
        }
      }
    } else {
      console.warn(`Урок ${lessonId} не имеет источника контента`);
    }
    guideTitle.innerText = `Guide: ${lesson.title || `Урок ${lesson.id}`}`;
    hideAllAudio();
    if (lesson.testSource) {
      testButton.classList.remove('hidden');
      testButton.onclick = function() { openTest(lesson); };
    } else {
      testButton.classList.add('hidden');
    }
    const audioInfo = courseManager.getAudioInfo();
    if (audioInfo) {
      console.log('Найдена информация об аудио для урока:', lesson.id);
      console.log('Аудио информация:', JSON.stringify(audioInfo));
      showAudioForLesson(lesson);
    } else {
      console.log('Для урока', lesson.id, 'аудио не найдено');
    }
    function showAudioForLesson(lesson) {
      hideAllAudio();
      if (!lesson) return;
      if (!lesson.audioSource && lesson.audio) {
        lesson.audioSource = lesson.audio;
        console.log('Присвоено audioSource из lesson.audio');
      }
      if (!lesson.audioSource) {
        console.log('У урока нет аудио источника');
        return;
      }
      console.log('Обработка аудио для урока:', lesson.id, 'Тип аудио:', lesson.audioSource.type);
      console.log('Данные аудио:', JSON.stringify(lesson.audioSource));
      const audioType = (lesson.audioSource.type || '').toLowerCase();
      const audioEmbed = document.getElementById('audio-embed');
      if (!audioEmbed) {
        console.warn('Элемент с id "audio-embed" не найден. Проверьте HTML-разметку.');
        return;
      }
      let embedContent = '';
      if (audioType === 'soundcloud') {
        if (lesson.audioSource.trackUrl) {
          embedContent = `<iframe src="${lesson.audioSource.trackUrl}" width="100%" height="166" frameborder="0" allow="autoplay"></iframe>`;
        } else if (lesson.audioSource.url) {
          embedContent = `<iframe src="${lesson.audioSource.url}" width="100%" height="166" frameborder="0" allow="autoplay"></iframe>`;
        } else if (lesson.audioSource.embedCode) {
          embedContent = lesson.audioSource.embedCode;
        } else if (lesson.audioSource.embed) {
          embedContent = lesson.audioSource.embed;
        }
      } else if (audioType === 'url' && lesson.audioSource.url) {
        embedContent = `<audio controls style="width:100%; max-width:600px;">
          <source src="${lesson.audioSource.url}" type="audio/mpeg">
          Ваш браузер не поддерживает аудио элемент.
        </audio>`;
      } else if (audioType === 'embed' && lesson.audioSource.embedCode) {
        embedContent = lesson.audioSource.embedCode;
      } else if (lesson.audioSource.url) {
        embedContent = `<audio controls style="width:100%; max-width:600px;">
          <source src="${lesson.audioSource.url}" type="audio/mpeg">
          Ваш браузер не поддерживает аудио элемент.
        </audio>`;
      }
      if (!embedContent) {
        console.error("Не удалось сформировать embedContent из audioSource:", lesson.audioSource);
        audioEmbed.innerHTML = "<p>Audio not available</p>";
        return;
      }
      audioEmbed.innerHTML = embedContent;
      audioEmbed.classList.remove('hidden');
      console.log('Аудио контейнер отображен с содержимым');
    }
    showSection('guide');
    const contentSpinner = document.getElementById('content-loading-spinner');
    if (contentSpinner) contentSpinner.classList.remove('hidden');
    loadLessonContent();
  };

  // Функция получения кешированного URL вебхука по ключу
  function getCachedWebhookUrl(key) {
    try {
      const cacheStr = localStorage.getItem('webhookUrlsCache');
      if (cacheStr) {
        const cache = JSON.parse(cacheStr);
        return cache[key];
      }
    } catch (e) {
      console.error('Ошибка при получении кешированного URL вебхука:', e);
    }
    return null;
  }

  // Загрузка теста для урока
  async function loadTestForLesson(lesson) {
    try {
      if (!lesson.day && courseManager.currentDay) {
        lesson.day = courseManager.currentDay.id;
      }
      if (!lesson.courseId && courseManager.currentProfession) {
        lesson.courseId = courseManager.currentProfession;
      }
      const testContent = await courseManager.fetchTest(lesson);
      if (!testContent) {
        alert('Тестовые данные отсутствуют');
        return;
      }
      window.quizData = testContent;
      startQuiz();
    } catch (error) {
      console.error('Ошибка загрузки теста:', error);
      alert('Ошибка загрузки теста: ' + error.message);
    }
  }

  // Открытие теста (для обратной совместимости)
  function openTest(lesson) {
    if (lesson.testSource && lesson.testSource.url) {
      loadTestForLesson(lesson);
    }
  }

  // Запуск теста через iframe (quiz.html)
  function startQuiz() {
    let quizFrame = document.getElementById('quiz-frame');
    if (!quizFrame) {
      quizFrame = document.createElement('iframe');
      quizFrame.id = 'quiz-frame';
      quizFrame.style.border = 'none';
      quizFrame.style.width = '100%';
      quizFrame.style.height = '100vh';
      quizFrame.style.position = 'fixed';
      quizFrame.style.top = '0';
      quizFrame.style.left = '0';
      quizFrame.style.zIndex = '9999';
      quizFrame.style.backgroundColor = '#f8f9fa';
      document.body.appendChild(quizFrame);
      const closeButton = document.createElement('button');
      closeButton.innerText = 'Закрыть тест';
      closeButton.style.position = 'fixed';
      closeButton.style.top = '10px';
      closeButton.style.right = '10px';
      closeButton.style.zIndex = '10000';
      closeButton.style.padding = '8px 15px';
      closeButton.style.border = 'none';
      closeButton.style.borderRadius = '5px';
      closeButton.style.backgroundColor = '#e74c3c';
      closeButton.style.color = 'white';
      closeButton.style.cursor = 'pointer';
      closeButton.onclick = function() {
        document.getElementById('quiz-frame').style.display = 'none';
        document.body.removeChild(closeButton);
      };
      document.body.appendChild(closeButton);
    } else {
      quizFrame.style.display = 'block';
    }
    quizFrame.src = 'quiz.html';
  }

  // Загрузка контента урока
  async function loadLessonContent() {
    const contentSpinner = document.getElementById('content-loading-spinner');
    if (contentSpinner) contentSpinner.classList.remove('hidden');
    markdownContent.classList.add('hidden');
    const globalLoadingOverlay = document.getElementById('global-loading-overlay');
    if (globalLoadingOverlay) {
      globalLoadingOverlay.style.display = 'flex';
      globalLoadingOverlay.style.opacity = '1';
      const globalStatusElement = document.getElementById('global-loading-status');
      if (globalStatusElement) {
        globalStatusElement.textContent = 'Загрузка контента урока...';
      }
    }
    try {
      if (!courseManager.currentLesson) {
        throw new Error('Не выбран урок для загрузки');
      }
      console.log('Запрос контента для урока:', courseManager.currentLesson.id);
      const content = await courseManager.fetchLessonContent();
      if (!content) {
        throw new Error('Получен пустой контент');
      }
      console.log(`Получен контент (${content.length} символов), форматирование...`);
      let processedContent = content;
      if (!content.trim().startsWith('#')) {
        processedContent = `# ${courseManager.currentLesson.title || 'Урок'}\n\n${content}`;
      }
      const formattedHTML = createCollapsibleBlocks(processedContent);
      console.log('Контент отформатирован, отображение...');
      markdownContent.innerHTML = formattedHTML;
      const task = courseManager.getTask();
      if (task) {
        console.log('Найдено задание для урока, добавление в контент');
        const taskHTML = marked.parse(task);
        const taskSection = document.createElement('div');
        taskSection.className = 'task-section';
        taskSection.innerHTML = `
          <h2>Practical Task</h2>
          <div class="task-content">${taskHTML}</div>
        `;
        markdownContent.appendChild(taskSection);
      }
      if (contentSpinner) contentSpinner.classList.add('hidden');
      markdownContent.classList.remove('hidden');
      if (globalLoadingOverlay) {
        globalLoadingOverlay.style.transition = 'opacity 0.5s';
        globalLoadingOverlay.style.opacity = '0';
        setTimeout(() => {
          globalLoadingOverlay.style.display = 'none';
        }, 500);
      }
      console.log('Контент урока успешно загружен и отображен');
    } catch (error) {
      console.error('Ошибка при загрузке контента урока:', error);
      const lessonTitle = courseManager.currentLesson 
        ? (courseManager.currentLesson.title || `Урок ${courseManager.currentLesson.id}`)
        : 'Неизвестный урок';
      markdownContent.innerHTML = `
        <div style="background-color: #fff0f0; padding: 15px; border-left: 4px solid #ff0000; margin-bottom: 20px;">
          <h3>Ошибка загрузки контента урока "${lessonTitle}"</h3>
          <p>Пожалуйста, обратитесь к руководителю команды.</p>
          <p><strong>Причина:</strong> ${error.message || error.toString()}</p>
          <div style="margin-top: 15px;">
            <button onclick="goBackToTaskSelection()" style="margin-right: 10px; background-color: #3498db; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer;">
              Вернуться к списку уроков
            </button>
            <button onclick="loadLessonContent()" style="margin-right: 10px; background-color: #f39c12; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer;">
              Повторить загрузку
            </button>
            <button onclick="location.reload()" style="background-color: #4CAF50; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer;">
              Перезагрузить страницу
            </button>
          </div>
        </div>
      `;
      if (contentSpinner) contentSpinner.classList.add('hidden');
      markdownContent.classList.remove('hidden');
      if (globalLoadingOverlay) {
        globalLoadingOverlay.style.transition = 'opacity 0.5s';
        globalLoadingOverlay.style.opacity = '0';
        setTimeout(() => {
          globalLoadingOverlay.style.display = 'none';
        }, 500);
      }
    }
  }

  // Функция открытия словаря
  window.openVocabulary = function() {
    selectLesson('vocabulary');
  };

  // Функция возврата к выбору дня
  window.goBackToDaySelection = function() {
    taskSelectionContainer.classList.add('hidden');
    daySelectionContainer.classList.remove('hidden');
  };

  // Функция возврата к выбору задания
  window.goBackToTaskSelection = function() {
    hideAllAudio();
    markdownContent.innerHTML = '';
    courseManager.currentLesson = null;
    homeContainer.classList.remove('hidden');
    if (courseManager.currentDay) {
      selectDay(courseManager.currentDay.id);
    }
    guideContainer.classList.add('hidden');
  };

  // Функция скрытия всех аудио
  function hideAllAudio() {
    const audioEmbed = document.getElementById("audio-embed");
    if (audioEmbed) {
      audioEmbed.classList.add("hidden");
      audioEmbed.innerHTML = '';
    }
    const legacyContainers = [
      "audio-first-lesson",
      "audio-vocabulary"
    ];
    legacyContainers.forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.classList.add("hidden");
      }
    });
    const audioContainers = document.querySelectorAll('.audio-container');
    if (audioContainers.length > 0) {
      audioContainers.forEach(container => {
        container.classList.add('hidden');
      });
      console.log(`Скрыто ${audioContainers.length} аудио контейнеров`);
    }
  }

  // Функция показа определенной секции
  function showSection(id) {
    homeContainer.classList.add('hidden');
    guideContainer.classList.add('hidden');
    const target = document.getElementById(id);
    if (target) target.classList.remove('hidden');
  }

  // Функция для создания раскрывающихся блоков из markdown
  function createCollapsibleBlocks(markdown) {
    markdown = markdown.trim();
    const lines = markdown.split("\n");
    let htmlOutput = "";
    let currentLevel1Title = "";
    let currentLevel1Content = [];
    let inLevel1 = false;
    if (lines.length > 0 && !lines[0].match(/^#\s+/)) {
      lines.unshift("# " + (window.currentTopic ? window.currentTopic.title : "Content"));
    }
    for (let line of lines) {
      let match = line.match(/^#(?!#)\s*(.+)/);
      if (match) {
        if (inLevel1) {
          htmlOutput += renderLevel1Block(currentLevel1Title, currentLevel1Content.join("\n"));
        }
        currentLevel1Title = match[1].trim();
        currentLevel1Content = [];
        inLevel1 = true;
      } else {
        if (inLevel1) {
          currentLevel1Content.push(line);
        }
      }
    }
    if (inLevel1) {
      htmlOutput += renderLevel1Block(currentLevel1Title, currentLevel1Content.join("\n"));
    } else if (!htmlOutput) {
      htmlOutput = marked.parse(markdown);
    }
    return htmlOutput;
  }

  function renderLevel1Block(title, content) {
    const lines = content.split("\n");
    let html = "";
    let subBlocksHtml = "";
    let currentSubTitle = "";
    let currentSubContent = [];
    let hasSubHeader = false;
    let preambleLines = [];
    for (let line of lines) {
      let subMatch = line.match(/^##(?!#)\s*(.+)/);
      if (subMatch) {
        hasSubHeader = true;
        if (currentSubTitle) {
          subBlocksHtml += renderLevel2Block(currentSubTitle, currentSubContent.join("\n"));
          currentSubContent = [];
        }
        currentSubTitle = subMatch[1].trim();
      } else {
        if (hasSubHeader) {
          currentSubContent.push(line);
        } else {
          preambleLines.push(line);
        }
      }
    }
    if (currentSubTitle) {
      subBlocksHtml += renderLevel2Block(currentSubTitle, currentSubContent.join("\n"));
    }
    if (preambleLines.length) {
      html += marked.parse(preambleLines.join("\n"));
    }
    html += subBlocksHtml;
    return `<details>
    <summary>${title}</summary>
    <div>${html}</div>
  </details>`;
  }

  function renderLevel2Block(title, content) {
    const lines = content.split("\n");
    let html = "";
    let subBlocksHtml = "";
    let currentSubTitle = "";
    let currentSubContent = [];
    let hasSubHeader = false;
    let preambleLines = [];
    for (let line of lines) {
      let subMatch = line.match(/^###(?!#)\s*(.+)/);
      if (subMatch) {
        hasSubHeader = true;
        if (currentSubTitle) {
          subBlocksHtml += renderLevel3Block(currentSubTitle, currentSubContent.join("\n"));
          currentSubContent = [];
        }
        currentSubTitle = subMatch[1].trim();
      } else {
        if (hasSubHeader) {
          currentSubContent.push(line);
        } else {
          preambleLines.push(line);
        }
      }
    }
    if (currentSubTitle) {
      subBlocksHtml += renderLevel3Block(currentSubTitle, currentSubContent.join("\n"));
    }
    if (preambleLines.length) {
      html += marked.parse(preambleLines.join("\n"));
    }
    html += subBlocksHtml;
    return `<details style="margin-left:20px;">
    <summary>${title}</summary>
    <div>${html}</div>
  </details>`;
  }

  function renderLevel3Block(title, content) {
    let parsedContent = marked.parse(content);
    return `<details style="margin-left:40px;">
    <summary>${title}</summary>
    <div>${parsedContent}</div>
  </details>`;
  }

  // Функция редиректа на страницу администрирования
  window.openAdminPanel = function() {
    window.location.href = 'admin.html';
  };

  // Инициализация приложения при загрузке
  document.addEventListener('DOMContentLoaded', initApp);

  // ==================== END APP CODE ====================


  // ==================== BEGIN FETCH TESTS CODE ====================
  // Скрипт для получения тестовых данных с вебхуков и сохранения их в JSON

  async function fetchTests() {
    console.log('Starting to fetch test data from webhooks...');
    const courseManager = window.courseManager || {};
    const courses = courseManager.courses || {};
    const testData = {};
    for (const courseId in courses) {
      const course = courses[courseId];
      testData[courseId] = { 
        title: course.title || courseId,
        days: [] 
      };
      if (course.days && Array.isArray(course.days)) {
        for (const day of course.days) {
          const dayData = {
            id: day.id,
            title: day.title || `Day ${day.id}`,
            lessons: []
          };
          if (day.lessons && Array.isArray(day.lessons)) {
            for (const lesson of day.lessons) {
              if (lesson.testSource && lesson.testSource.url) {
                console.log(`Found test webhook for lesson ${lesson.id}: ${lesson.testSource.url}`);
                try {
                  const testContent = await fetchTestContent(lesson.testSource.url);
                  dayData.lessons.push({
                    id: lesson.id,
                    title: lesson.title,
                    testData: testContent
                  });
                } catch (error) {
                  console.error(`Error fetching test for ${lesson.id}:`, error);
                  dayData.lessons.push({
                    id: lesson.id,
                    title: lesson.title,
                    testData: null,
                    error: error.message
                  });
                }
              } else {
                dayData.lessons.push({
                  id: lesson.id,
                  title: lesson.title,
                  testData: null
                });
              }
            }
          }
          testData[courseId].days.push(dayData);
        }
      }
      if (course.specialLessons && Array.isArray(course.specialLessons)) {
        if (!testData[courseId].specialLessons) {
          testData[courseId].specialLessons = [];
        }
        for (const lesson of course.specialLessons) {
          if (lesson.testSource && lesson.testSource.url) {
            console.log(`Found test webhook for special lesson ${lesson.id}: ${lesson.testSource.url}`);
            try {
              const testContent = await fetchTestContent(lesson.testSource.url);
              testData[courseId].specialLessons.push({
                id: lesson.id,
                title: lesson.title,
                testData: testContent
              });
            } catch (error) {
              console.error(`Error fetching test for special lesson ${lesson.id}:`, error);
              testData[courseId].specialLessons.push({
                id: lesson.id,
                title: lesson.title,
                testData: null,
                error: error.message
              });
            }
          } else {
            testData[courseId].specialLessons.push({
              id: lesson.id,
              title: lesson.title,
              testData: null
            });
          }
        }
      }
    }
    saveTestsToFile(testData);
    return testData;
  }

  async function fetchTestContent(url) {
    console.log(`Fetching test data from: ${url}`);
    try {
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Accept': 'application/json, text/plain, */*',
          'Content-Type': 'application/json',
          'Cache-Control': 'no-cache'
        },
        cache: 'no-store',
        mode: 'cors',
        credentials: 'omit'
      });
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      const responseText = await response.text();
      console.log(`Received response from ${url}, length: ${responseText.length} bytes`);
      try {
        const data = JSON.parse(responseText);
        return processTestData(data);
      } catch (jsonError) {
        console.log('Response is not JSON, trying to parse as HTML or extract JSON from text');
        const jsonMatch = responseText.match(/{[\s\S]*}/);
        if (jsonMatch && jsonMatch[0]) {
          try {
            const extractedData = JSON.parse(jsonMatch[0]);
            return processTestData(extractedData);
          } catch (e) {
            console.error('Failed to extract JSON from text response');
          }
        }
        if (responseText.includes('<!DOCTYPE html>') || responseText.includes('<html>')) {
          return extractTestFromHTML(responseText);
        }
        return {
          rawContent: responseText,
          format: 'text',
          parsed: false
        };
      }
    } catch (error) {
      console.error(`Error fetching test content from ${url}:`, error);
      throw error;
    }
  }

  function processTestData(data) {
    if (data.questions) {
      return {
        name: data.name || data.title || 'Unnamed Test',
        description: data.description || '',
        questions: data.questions.map(q => ({
          question: q.question || q.text || '',
          options: q.options || q.answers || [],
          correctAnswer: q.correctAnswer || q.correct || q.correct_answer || '',
          points: q.points || 1
        })),
        format: 'json',
        parsed: true,
        task: data.task || null
      };
    } else if (data.test && data.test.questions) {
      return {
        name: data.test.name || data.test.title || 'Unnamed Test',
        description: data.test.description || '',
        questions: data.test.questions.map(q => ({
          question: q.question || q.text || '',
          options: q.options || q.answers || [],
          correctAnswer: q.correctAnswer || q.correct || q.correct_answer || '',
          points: q.points || 1
        })),
        format: 'json',
        parsed: true,
        task: data.test.task || data.task || null
      };
    } else if (Array.isArray(data)) {
      return {
        name: 'Unnamed Test',
        description: '',
        questions: data.map(q => ({
          question: q.question || q.text || '',
          options: q.options || q.answers || [],
          correctAnswer: q.correctAnswer || q.correct || q.correct_answer || '',
          points: q.points || 1
        })),
        format: 'json',
        parsed: true
      };
    }
    return {
      rawData: data,
      format: 'json',
      parsed: false
    };
  }

  function extractTestFromHTML(html) {
    const testData = {
      name: '',
      description: '',
      questions: [],
      format: 'html',
      parsed: false
    };
    const titleMatch = html.match(/<title>(.*?)<\/title>/);
    if (titleMatch && titleMatch[1]) {
      testData.name = titleMatch[1].trim();
    }
    const questionRegex = /<div class="question"[^>]*data-points="(\d+)"[^>]*>\s*<h3>(.*?)<\/h3>([\s\S]*?)<\/div>/g;
    let match;
    while ((match = questionRegex.exec(html)) !== null) {
      const points = parseInt(match[1]) || 1;
      const questionText = match[2].replace(/<[^>]*>/g, '').trim();
      const optionsHTML = match[3];
      const options = [];
      let correctAnswer = '';
      const optionRegex = /<label><input type="radio" name="[^"]*" value="([^"]*)"(?:\s+data-correct="([^"]*)")?\s*>\s*(.*?)<\/label>/g;
      let optionMatch;
      while ((optionMatch = optionRegex.exec(optionsHTML)) !== null) {
        const value = optionMatch[1];
        const isCorrect = optionMatch[2] === 'true';
        const text = optionMatch[3].replace(/<[^>]*>/g, '').trim();
        options.push({ value, text });
        if (isCorrect) {
          correctAnswer = value;
        }
      }
      testData.questions.push({
        question: questionText,
        options,
        correctAnswer,
        points
      });
    }
    testData.parsed = testData.questions.length > 0;
    return testData;
  }

  function saveTestsToFile(data) {
    const jsonData = JSON.stringify(data, null, 2);
    function saveToFileSystem(content, filename) {
      try {
        if (window.fetch) {
          try {
            fetch('/save-tests', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ content, filename })
            })
            .then(response => response.text())
            .then(result => {
              console.log('Server save result:', result);
            })
            .catch(error => {
              console.error('Error saving via server:', error);
            });
          } catch (e) {
            console.error('Error trying to save via server:', e);
          }
        }
      } catch (error) {
        console.error('Error preparing file for download:', error);
      }
    }
    saveToFileSystem(jsonData, 'tests.json');
    console.log('Tests data prepared for server save');
  }

  // Запуск получения тестовых данных после инициализации courseManager
  if (typeof window !== 'undefined') {
    let waitCount = 0;
    const maxWaits = 30;
    function waitForCourseManager() {
      if (window.courseManager && window.courseManager.courses) {
        fetchTests().then(testData => {
          console.log('Test data fetch complete, data saved');
          window.testData = testData;
        });
      } else {
        waitCount++;
        if (waitCount <= maxWaits) {
          console.log(`Waiting for courseManager to be initialized... (${waitCount}/${maxWaits})`);
          setTimeout(waitForCourseManager, 1000);
        } else {
          console.warn('Exceeded maximum wait time for courseManager. Aborting test data fetch.');
        }
      }
    }
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', function() {
        setTimeout(waitForCourseManager, 3000);
      });
    } else {
      setTimeout(waitForCourseManager, 3000);
    }
  }

  // ==================== END FETCH TESTS CODE ====================
  </script>
  </body>
  </html>