<!DOCTYPE html>
<html lang="ru">
<head>
  <link type="image/png" sizes="16x16" rel="icon" href="https://i.postimg.cc/gJf9MgWR/icons8-32.png">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Onboarding for Prompt Engineers</title>
  <!-- Подключаем marked.js для парсинга Markdown -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background-color: #f0f0f0;
    }
    .container {
      padding: 20px;
    }
    .hidden {
      display: none;
    }
    .center {
      text-align: center;
    }
    button {
      padding: 10px 20px;
      margin: 10px;
      cursor: pointer;
      border: none;
      background-color: #4CAF50;
      color: white;
      border-radius: 5px;
    }
    button:hover {
      background-color: #45a049;
    }
    .spinner {
      border: 8px solid #f3f3f3;
      border-top: 8px solid #3498db;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 2s linear infinite;
      margin: 20px auto;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .markdown-content p {
      margin: 10px 0;
    }
    .markdown-content ul {
      margin: 10px 20px;
      padding-left: 20px;
    }
    .markdown-content table {
      border-collapse: collapse;
      width: 100%;
      margin: 10px 0;
    }
    .markdown-content table,
    .markdown-content th,
    .markdown-content td {
      border: 1px solid #ddd;
    }
    .markdown-content th,
    .markdown-content td {
      padding: 8px;
      text-align: left;
    }
    details {
      background: #fff;
      margin: 10px 0;
      padding: 10px;
      border-radius: 5px;
    }
    summary {
      cursor: pointer;
    }
    details > summary {
      font-size: 1.2em;
      font-weight: bold;
    }
    details details > summary {
      font-size: 0.9em;
      font-weight: bold;
    }
    details details details > summary {
      font-size: 0.8em;
      font-weight: bold;
    }
    .markdown-content pre {
      background-color: #f9f9f9;
      border-left: 4px solid #ccc;
      padding: 10px;
      overflow-x: auto;
      white-space: pre-wrap;
      word-wrap: break-word;
      margin: 10px 0;
    }
    .markdown-content code {
      background-color: #f9f9f9;
      padding: 2px 4px;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <!-- Домашняя страница -->
  <div id="home" class="container center">
    <div id="day-selection">
      <h1>Prompt Engineering Onboarding</h1>
      <p>
        Profession:&nbsp;
        <select id="profession-select" onchange="handleProfessionChange()">
          <option value="prompt-engineer">Prompt Engineer</option>
          <option value="lead-generator">Lead Generator</option>
        </select>
      </p>

      <div style="margin: 30px 0;">
        <p>Quick Reference:</p>
        <button onclick="openVocabulary()">Prompt Engineering Vocabulary</button>
      </div>

      <div style="margin-top: 30px;">
        <p>Select Training Day:</p>
        <button onclick="selectDay(1)">Day 1</button>
        <button onclick="selectDay(2)">Day 2</button>
      </div>
    </div>
    <div id="task-selection" class="hidden">
      <h1 id="day-header"></h1>
      <div id="task-buttons"></div>
      <button onclick="goBackToDaySelection()">Back</button>
    </div>
  </div>

  <!-- Страница гайда -->
  <div id="guide" class="container hidden">
    <h1 id="guide-title">Guide:</h1>
    <div id="loading-spinner" class="center">
      <div class="spinner"></div>
      <p>Loading, please wait...</p>
    </div>

    <!-- Аудио-блок для первого урока -->
    <div id="audio-first-lesson" class="hidden center" style="margin-bottom: 20px;">
      <iframe width="100%" height="300" scrolling="no" frameborder="no" allow="autoplay"
              src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/2041898968&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true&visual=true">
      </iframe>
      <div style="font-size: 10px; color: #cccccc;line-break: anywhere;word-break: normal;overflow: hidden;white-space: nowrap;text-overflow: ellipsis; font-family: Interstate,Lucida Grande,Lucida Sans Unicode,Lucida Sans,Garuda,Verdana,Tahoma,sans-serif;font-weight: 100;">
        <a href="https://soundcloud.com/content-remote-helpers" title="Content Remote Helpers" target="_blank" style="color: #cccccc; text-decoration: none;">Content Remote Helpers</a> · <a href="https://soundcloud.com/content-remote-helpers/screen-recording-audio" title="First Lesson Audio" target="_blank" style="color: #cccccc; text-decoration: none;">First Lesson Audio</a>
      </div>
    </div>

    <!-- Аудио-блок для Vocabulary -->
    <div id="audio-vocabulary" class="hidden center" style="margin-bottom: 20px;">
      <iframe width="100%" height="300" scrolling="no" frameborder="no" allow="autoplay"
              src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/2028455920&color=%230066cc&auto_play=false">
      </iframe>
      <div style="font-size: 10px; color: #cccccc; white-space: nowrap;">
        <a href="https://soundcloud.com/developers-remote-helpers" target="_blank" style="color: #cccccc; text-decoration: none;">
          Developers Remote Helpers</a> ·
        <a href="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/2028455920" target="_blank" style="color: #cccccc; text-decoration: none;">
          Prompt Engineering Vocabulary</a>
      </div>
    </div>

    <!-- Контейнер для Markdown контента -->
    <div id="markdown-content" class="markdown-content hidden"></div>

    <!-- Кнопка Test для выбранного модуля -->
    <div class="center" style="margin-top:20px;">
      <button id="test-button" onclick="window.location.href = currentTopic.testWebhook">Test</button>
    </div>
    <!-- Кнопка Back для возврата к списку топиков -->
    <div class="center" style="margin-top:20px;">
      <button onclick="goBackToTaskSelection()">Back</button>
    </div>
  </div>

  <script>
    // Глобальные переменные для текущей темы и выбранного дня
    window.currentTopic = null;
    window.currentDay = null;
    let currentTasks = [];

    const professionTasks = {
      "prompt-engineer": {
        1: [
          { 
            title: "What prompting is",
            contentWebhook: "https://auto.crm-s.com/webhook/PromptEngineering/WhatPromptingIs",
            testWebhook: "https://hook.eu1.make.com/7abcirtnwr3o5w2p3480yxcpbzjhdnxg" 
          },
          { 
            title: "Five-step Framework",
            contentWebhook: "https://hook.eu1.make.com/rsy54qf695aukcfwuvhmxbdxix8u6ue9",
            testWebhook: "https://hook.eu1.make.com/35zujy3zx8at4dmxuitwe37o53b2s2m4" 
          },
          { 
            title: "Personas in prompting",
            contentWebhook: "https://hook.eu1.make.com/4lrubal04k6pfg5rgualtjxiji7p74ij",
            testWebhook: "https://hook.eu1.make.com/dgecm6fr54b9fpesbhf3iq7id434v6na" 
          }
        ],
        2: [
          {
            title: "Iteration methods",
            contentWebhook: "https://hook.eu1.make.com/8ug4oj2ll6hafgjn2u2bi8bkmunxoms5",
            testWebhook: "https://hook.eu1.make.com/i52b5tanhf0exgbxemfj0dfrxdiuaclh"
          },
          {
            title: "multimodal prompting",
            contentWebhook: "https://hook.eu1.make.com/aw8bbsalo3dx4wlkurjxp713tlubh8l8",
            testWebhook: "https://hook.eu1.make.com/4yavh61809vwudjltlardrox3w98i7kj"
          },
          {
            title: "responsible AI Use",
            contentWebhook: "https://hook.eu1.make.com/ya6a12917mjqwfx9lhpxf9wy3now3f4r",
            testWebhook: "https://hook.eu1.make.com/cjn0iv6d6l6pdpzv9of1bpohnv419omj"
          }
        ]
      }
    };

    // Отдельный объект для словаря
    const vocabularyTopic = {
      title: "Prompt Engineering Vocabulary",
      contentWebhook: "https://auto.crm-s.com/webhook/PromptEngineering/Vocabulary",
      testWebhook: "placeholder-test-webhook-vocabulary"
    };

    // Функция для обработки изменения профессии
    function handleProfessionChange() {
      const selectedProfession = document.getElementById("profession-select").value;
      if (selectedProfession === "lead-generator") {
        window.location.href = "https://hook.eu1.make.com/jcjl176nvrhlm4ag7qiixjzssxqdbl5n";
      }
    }

    function selectDay(day) {
      window.currentDay = day;
      const selectedProfession = document.getElementById("profession-select").value;
      // Используем deep copy, чтобы не изменялись исходные данные
      currentTasks = JSON.parse(JSON.stringify(professionTasks[selectedProfession][day]));
      const dayHeader = document.getElementById("day-header");
      if (dayHeader) dayHeader.innerText = "Day " + day;
      const daySelection = document.getElementById("day-selection");
      if (daySelection) daySelection.classList.add("hidden");
      const taskSelection = document.getElementById("task-selection");
      if (taskSelection) taskSelection.classList.remove("hidden");
      const taskButtonsDiv = document.getElementById("task-buttons");
      if (taskButtonsDiv) {
        taskButtonsDiv.innerHTML = "";
        currentTasks.forEach((task, index) => {
          const btn = document.createElement("button");
          btn.innerText = task.title;
          btn.onclick = function() { selectTask(index); };
          taskButtonsDiv.appendChild(btn);
        });
      }
    }

    function goBackToDaySelection() {
      const taskSelection = document.getElementById("task-selection");
      if (taskSelection) taskSelection.classList.add("hidden");
      const daySelection = document.getElementById("day-selection");
      if (daySelection) daySelection.classList.remove("hidden");
    }

    // Функция возврата к списку топиков – обновляет его через selectDay с сохранённым днем и сбрасывает выбранный топик
    function goBackToTaskSelection() {
      hideAllAudio();
      const markdownDiv = document.getElementById("markdown-content");
      if (markdownDiv) markdownDiv.innerHTML = "";
      window.currentTopic = null;
      const home = document.getElementById("home");
      if (home) home.classList.remove("hidden");
      if (window.currentDay !== null) {
        selectDay(window.currentDay);
      }
      const guide = document.getElementById("guide");
      if (guide) guide.classList.add("hidden");
    }

    window.goBack = function() {
      showSection("home");
      const daySelection = document.getElementById("day-selection");
      if (daySelection) daySelection.classList.remove("hidden");
      const taskSelection = document.getElementById("task-selection");
      if (taskSelection) taskSelection.classList.add("hidden");
    };

    // Функция для открытия словаря
    function openVocabulary() {
      window.currentTopic = vocabularyTopic;
      const guideTitle = document.getElementById("guide-title");
      if (guideTitle) guideTitle.innerText = "Guide: " + window.currentTopic.title;
      hideAllAudio();
      // Аудио для Vocabulary остается скрытым
      // Скрываем кнопку теста для словаря
      document.getElementById("test-button").classList.add("hidden");
      showSection("guide");
      fetchMarkdownContent();
    }

    function selectTask(index) {
      window.currentTopic = currentTasks[index];
      const guideTitle = document.getElementById("guide-title");
      if (guideTitle) guideTitle.innerText = "Guide: " + window.currentTopic.title;
      hideAllAudio();
      // Показываем кнопку теста для обычных тем
      document.getElementById("test-button").classList.remove("hidden");
      showSection("guide");
      fetchMarkdownContent();
    }

    function hideAllAudio() {
      const audioIds = [
        "audio-first-lesson",
        "audio-vocabulary"
      ];
      audioIds.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.classList.add("hidden");
      });
    }

    function showSection(id) {
      const home = document.getElementById("home");
      if (home) home.classList.add("hidden");
      const guide = document.getElementById("guide");
      if (guide) guide.classList.add("hidden");
      const target = document.getElementById(id);
      if (target) target.classList.remove("hidden");
    }

    function fetchMarkdownContent() {
      const url = window.currentTopic.contentWebhook;
      const spinner = document.getElementById("loading-spinner");
      if (spinner) spinner.classList.remove("hidden");
      const markdownDiv = document.getElementById("markdown-content");
      if (markdownDiv) markdownDiv.classList.add("hidden");

      if (!url || url.startsWith("placeholder")) {
        if (spinner) spinner.classList.add("hidden");
        if (markdownDiv) {
          markdownDiv.classList.remove("hidden");
          markdownDiv.innerHTML = "<p>Placeholder content: Content will be added soon!</p>";
        }
        return;
      }

      let fetchOptions = {
        method: "POST",
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({}) // Send empty JSON object as body
      };

      fetch(url, fetchOptions)
        .then(response => {
          console.log("Response status:", response.status);
          return response.text();
        })
        .then(responseText => {
          console.log("Received content:", responseText.substring(0, 100) + "...");
          
          // Try to parse as JSON first
          let markdown;
          try {
            const responseJson = JSON.parse(responseText);
            // If it's JSON, extract the text content from the appropriate field
            if (responseJson.text) {
              markdown = responseJson.text;
            } else if (responseJson.content) {
              markdown = responseJson.content;
            } else if (responseJson.markdown) {
              markdown = responseJson.markdown;
            } else {
              // If no known field, use the whole JSON as string
              markdown = JSON.stringify(responseJson, null, 2);
            }
          } catch (e) {
            // If not JSON, use the text directly
            markdown = responseText;
          }

          if (!markdown.includes('#')) {
            markdown = "# " + window.currentTopic.title + "\n\n" + markdown;
          }

          const collapsibleHTML = createCollapsibleBlocks(markdown);
          if (markdownDiv) {
            markdownDiv.innerHTML = collapsibleHTML;
            spinner.classList.add("hidden");
            markdownDiv.classList.remove("hidden");
          }
        })
        .catch(error => {
          console.error("Loading error:", error);
          if (spinner) {
            spinner.classList.add("hidden");
          }
          if (markdownDiv) {
            markdownDiv.classList.remove("hidden");
            markdownDiv.innerHTML = `
              <p>Ошибка загрузки контента. Пожалуйста, обратитесь к руководителю команды.</p>
              <p>Детали ошибки: ${error.toString()}</p>
              <p>URL: ${url}</p>
            `;
          }

          // Just load some hardcoded text for specific topics
          if (window.currentTopic && window.currentTopic.title === "What prompting is") {
            const defaultContent = `# What prompting is

Prompting is a technique used to communicate with AI language models by providing them with specific instructions or input texts that guide their responses. It's the primary way humans interact with Large Language Models (LLMs) like ChatGPT, Claude, or Gemini.

## Why Prompts Matter

Effective prompts are crucial because they directly influence the quality and relevance of AI responses. The same AI model can generate dramatically different outputs based solely on how a prompt is phrased.

## Key Components of Prompts

### Instructions
Clear directions telling the AI what to do, how to respond, or what format to use.

### Context
Background information that helps the AI understand the topic or situation.

### Examples
Demonstrations of desired outputs that help the AI understand exactly what you want.

### Constraints
Limitations or boundaries that define what the AI should or shouldn't do.

## Different Types of Prompting

### Basic Prompting
Simple questions or statements that request information.
Example: "Explain what photosynthesis is."

### Role-Based Prompting
Asking the AI to assume a specific persona or role.
Example: "As an expert botanist, explain what photosynthesis is."

### Few-Shot Prompting
Providing examples in the prompt to guide the AI's response format.
Example: "Q: What is the capital of France? A: Paris. Q: What is the capital of Japan? A:"

### Chain-of-Thought Prompting
Encouraging the AI to reason step-by-step through a problem.
Example: "Think step by step to solve this math problem: If x + y = 10 and x - y = 4, what are x and y?"

## Prompt Engineering

The practice of designing and refining prompts to get the best possible responses from AI is called prompt engineering. It has become a valuable skill as AI systems become more widespread.

Good prompt engineers understand:
- How different prompting techniques affect AI outputs
- Common pitfalls and how to avoid them
- How to iterate and refine prompts
- How to evaluate AI responses

## The Prompt Engineering Workflow

1. Define your goal clearly
2. Design an initial prompt
3. Evaluate the response
4. Refine the prompt based on the response
5. Repeat until satisfied with the result

The following lessons will explore these concepts in more detail and provide practical exercises to develop your prompt engineering skills.`;
            
            markdownDiv.innerHTML = createCollapsibleBlocks(defaultContent);
            if (spinner) spinner.classList.add("hidden");
            markdownDiv.classList.remove("hidden");
          } else if (window.currentTopic && window.currentTopic.title === "Prompt Engineering Vocabulary") {
            const vocabularyContent = `# Prompt Engineering Vocabulary

## Core Concepts

### Prompt
A text input given to an AI model that guides its response. This can include questions, instructions, examples, or constraints.

### Large Language Model (LLM)
An AI system trained on vast amounts of text data that can generate human-like text, understand context, and follow instructions.

### Prompt Engineering
The practice of designing and refining prompts to effectively communicate with AI models to get desired outputs.

### Token
The basic unit of text that LLMs process. A token can be a word, part of a word, or a character, depending on the model's tokenization method.

### Context Window
The maximum amount of text (measured in tokens) that an AI model can consider at once, including both the prompt and the generated response.

## Prompting Techniques

### Zero-shot Prompting
Asking an AI to perform a task without providing any examples.
Example: "Translate this sentence to French: 'Hello, how are you?'"

### Few-shot Prompting
Providing the AI with a few examples within the prompt to guide its response format or style.
Example: "English: Hello, French: Bonjour, English: Thank you, French: ?"

### Chain-of-Thought (CoT)
Prompting technique that encourages the AI to show its reasoning process step-by-step.
Example: "Think step by step to solve this math problem."

### Tree of Thoughts
An extension of Chain-of-Thought that explores multiple reasoning paths before arriving at a final answer.

### Role Prompting
Instructing the AI to assume a specific role or persona.
Example: "As an experienced chef, provide feedback on this recipe."

### Retrieval-Augmented Generation (RAG)
Combining an LLM with the ability to retrieve information from an external knowledge base during generation.

## Best Practices

### Specificity
Being clear and detailed in what you're asking the AI to do.

### Structured Format
Organizing prompts with clear sections like "Context," "Instructions," and "Format."

### Constraints
Setting boundaries on what the AI should or shouldn't include in its response.

### Iteration
The process of refining prompts based on the AI's responses to improve results over time.

## Common Challenges

### Prompt Injection
A security concern where malicious instructions are hidden within benign-looking prompts to manipulate the AI's behavior.

### Hallucination
When an AI confidently generates incorrect information that wasn't in its training data.

### Model Alignment
The degree to which an AI's outputs match human values, intentions, and expectations.

### Context Truncation
When a prompt is too long and exceeds the model's context window, causing information loss.`;
            
            markdownDiv.innerHTML = createCollapsibleBlocks(vocabularyContent);
            if (spinner) spinner.classList.add("hidden");
            markdownDiv.classList.remove("hidden");
          }
        });
    }

    function createCollapsibleBlocks(markdown) {
      markdown = markdown.trim();

      const lines = markdown.split("\n");
      let htmlOutput = "";
      let currentLevel1Title = "";
      let currentLevel1Content = [];
      let inLevel1 = false;

      if (lines.length > 0 && !lines[0].match(/^#\s+/)) {
        lines.unshift("# " + (window.currentTopic ? window.currentTopic.title : "Content"));
      }

      for (let line of lines) {
        let match = line.match(/^#(?!#)\s*(.+)/);
        if (match) {
          if (inLevel1) {
            htmlOutput += renderLevel1Block(currentLevel1Title, currentLevel1Content.join("\n"));
          }
          currentLevel1Title = match[1].trim();
          currentLevel1Content = [];
          inLevel1 = true;
        } else {
          if (inLevel1) {
            currentLevel1Content.push(line);
          }
        }
      }
      if (inLevel1) {
        htmlOutput += renderLevel1Block(currentLevel1Title, currentLevel1Content.join("\n"));
      } else if (!htmlOutput) {
        htmlOutput = marked.parse(markdown);
      }
      return htmlOutput;
    }

    function renderLevel1Block(title, content) {
      const lines = content.split("\n");
      let html = "";
      let subBlocksHtml = "";
      let currentSubTitle = "";
      let currentSubContent = [];
      let hasSubHeader = false;
      let preambleLines = [];

      for (let line of lines) {
        let subMatch = line.match(/^##(?!#)\s*(.+)/);
        if (subMatch) {
          hasSubHeader = true;
          if (currentSubTitle) {
            subBlocksHtml += renderLevel2Block(currentSubTitle, currentSubContent.join("\n"));
            currentSubContent = [];
          }
          currentSubTitle = subMatch[1].trim();
        } else {
          if (hasSubHeader) {
            currentSubContent.push(line);
          } else {
            preambleLines.push(line);
          }
        }
      }
      if (currentSubTitle) {
        subBlocksHtml += renderLevel2Block(currentSubTitle, currentSubContent.join("\n"));
      }
      if (preambleLines.length) {
        html += marked.parse(preambleLines.join("\n"));
      }
      html += subBlocksHtml;
      return `<details>
  <summary>${title}</summary>
  <div>${html}</div>
</details>`;
    }

    function renderLevel2Block(title, content) {
      const lines = content.split("\n");
      let html = "";
      let subBlocksHtml = "";
      let currentSubTitle = "";
      let currentSubContent = [];
      let hasSubHeader = false;
      let preambleLines = [];

      for (let line of lines) {
        let subMatch = line.match(/^###(?!#)\s*(.+)/);
        if (subMatch) {
          hasSubHeader = true;
          if (currentSubTitle) {
            subBlocksHtml += renderLevel3Block(currentSubTitle, currentSubContent.join("\n"));
            currentSubContent = [];
          }
          currentSubTitle = subMatch[1].trim();
        } else {
          if (hasSubHeader) {
            currentSubContent.push(line);
          } else {
            preambleLines.push(line);
          }
        }
      }
      if (currentSubTitle) {
        subBlocksHtml += renderLevel3Block(currentSubTitle, currentSubContent.join("\n"));
      }
      if (preambleLines.length) {
        html += marked.parse(preambleLines.join("\n"));
      }
      html += subBlocksHtml;
      return `<details style="margin-left:20px;">
  <summary>${title}</summary>
  <div>${html}</div>
</details>`;
    }

    function renderLevel3Block(title, content) {
      let parsedContent = marked.parse(content);
      return `<details style="margin-left:40px;">
  <summary>${title}</summary>
  <div>${parsedContent}</div>
</details>`;
    }
  </script>
</body>
</html>