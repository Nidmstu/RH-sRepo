<!DOCTYPE html>
<html lang="ru">
<head>
  <link type="image/png" sizes="16x16" rel="icon" href="https://i.postimg.cc/gJf9MgWR/icons8-32.png">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Onboarding for Prompt Engineers</title>
  <!-- Подключаем marked.js для парсинга Markdown -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background-color: #f0f0f0;
    }
    .container {
      padding: 20px;
    }
    .hidden {
      display: none;
    }
    .center {
      text-align: center;
    }
    button {
      padding: 10px 20px;
      margin: 10px;
      cursor: pointer;
      border: none;
      background-color: #4CAF50;
      color: white;
      border-radius: 5px;
    }
    button:hover {
      background-color: #45a049;
    }
    .spinner {
      border: 8px solid #f3f3f3;
      border-top: 8px solid #3498db;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 2s linear infinite;
      margin: 20px auto;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .markdown-content p {
      margin: 10px 0;
    }
    .markdown-content ul {
      margin: 10px 20px;
      padding-left: 20px;
    }
    .markdown-content table {
      border-collapse: collapse;
      width: 100%;
      margin: 10px 0;
    }
    .markdown-content table,
    .markdown-content th,
    .markdown-content td {
      border: 1px solid #ddd;
    }
    .markdown-content th,
    .markdown-content td {
      padding: 8px;
      text-align: left;
    }
    details {
      background: #fff;
      margin: 10px 0;
      padding: 10px;
      border-radius: 5px;
    }
    summary {
      cursor: pointer;
    }
    details > summary {
      font-size: 1.2em;
      font-weight: bold;
    }
    details details > summary {
      font-size: 0.9em;
      font-weight: bold;
    }
    details details details > summary {
      font-size: 0.8em;
      font-weight: bold;
    }
    .markdown-content pre {
      background-color: #f9f9f9;
      border-left: 4px solid #ccc;
      padding: 10px;
      overflow-x: auto;
      white-space: pre-wrap;
      word-wrap: break-word;
      margin: 10px 0;
    }
    .markdown-content code {
      background-color: #f9f9f9;
      padding: 2px 4px;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <!-- Домашняя страница -->
  <div id="home" class="container center">
    <div id="day-selection">
      <h1>Prompt Engineering Onboarding</h1>
      <p>
        Profession:&nbsp;
        <select id="profession-select" onchange="handleProfessionChange()">
          <option value="prompt-engineer">Prompt Engineer</option>
          <option value="lead-generator">Lead Generator</option>
        </select>
      </p>

      <div style="margin: 30px 0;">
        <p>Quick Reference:</p>
        <button onclick="openVocabulary()">Prompt Engineering Vocabulary</button>
      </div>

      <div style="margin-top: 30px;">
        <p>Select Training Day:</p>
        <button onclick="selectDay(1)">Day 1</button>
        <button onclick="selectDay(2)">Day 2</button>
      </div>
    </div>
    <div id="task-selection" class="hidden">
      <h1 id="day-header"></h1>
      <div id="task-buttons"></div>
      <button onclick="goBackToDaySelection()">Back</button>
    </div>
  </div>

  <!-- Страница гайда -->
  <div id="guide" class="container hidden">
    <h1 id="guide-title">Guide:</h1>
    <div id="loading-spinner" class="center">
      <div class="spinner"></div>
      <p>Loading, please wait...</p>
    </div>

    <!-- Аудио-блок для первого урока -->
    <div id="audio-first-lesson" class="hidden center" style="margin-bottom: 20px;">
      <iframe width="100%" height="300" scrolling="no" frameborder="no" allow="autoplay"
              src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/2041898968&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true&visual=true">
      </iframe>
      <div style="font-size: 10px; color: #cccccc;line-break: anywhere;word-break: normal;overflow: hidden;white-space: nowrap;text-overflow: ellipsis; font-family: Interstate,Lucida Grande,Lucida Sans Unicode,Lucida Sans,Garuda,Verdana,Tahoma,sans-serif;font-weight: 100;">
        <a href="https://soundcloud.com/content-remote-helpers" title="Content Remote Helpers" target="_blank" style="color: #cccccc; text-decoration: none;">Content Remote Helpers</a> · <a href="https://soundcloud.com/content-remote-helpers/screen-recording-audio" title="First Lesson Audio" target="_blank" style="color: #cccccc; text-decoration: none;">First Lesson Audio</a>
      </div>
    </div>

    <!-- Аудио-блок для Vocabulary -->
    <div id="audio-vocabulary" class="hidden center" style="margin-bottom: 20px;">
      <iframe width="100%" height="300" scrolling="no" frameborder="no" allow="autoplay"
              src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/2028455920&color=%230066cc&auto_play=false">
      </iframe>
      <div style="font-size: 10px; color: #cccccc; white-space: nowrap;">
        <a href="https://soundcloud.com/developers-remote-helpers" target="_blank" style="color: #cccccc; text-decoration: none;">
          Developers Remote Helpers</a> ·
        <a href="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/2028455920" target="_blank" style="color: #cccccc; text-decoration: none;">
          Prompt Engineering Vocabulary</a>
      </div>
    </div>

    <!-- Контейнер для Markdown контента -->
    <div id="markdown-content" class="markdown-content hidden"></div>

    <!-- Кнопка Test для выбранного модуля -->
    <div class="center" style="margin-top:20px;">
      <button id="test-button" onclick="window.location.href = currentTopic.testWebhook">Test</button>
    </div>
    <!-- Кнопка Back для возврата к списку топиков -->
    <div class="center" style="margin-top:20px;">
      <button onclick="goBackToTaskSelection()">Back</button>
    </div>
  </div>

  <script>
    // Глобальные переменные для текущей темы и выбранного дня
    window.currentTopic = null;
    window.currentDay = null;
    let currentTasks = [];

    const professionTasks = {
      "prompt-engineer": {
        1: [
          { 
            title: "What prompting is",
            contentWebhook: "https://auto.crm-s.com/webhook/PromptEngineering/WhatPromptingIs",
            testWebhook: "https://auto.crm-s.com/webhook/PromptEngineering/Tests/WhatPromptingIs" 
          },
          { 
            title: "Five-step Framework",
            contentWebhook: "https://auto.crm-s.com/webhook/Onboarding/PromptEngineer/FiveStepFramework",
            testWebhook: "https://auto.crm-s.com/webhook/Oboarding/PromptEngineering/tests/FiveStepFramework" 
          },
          { 
            title: "Personas in prompting",
            contentWebhook: "https://auto.crm-s.com/webhook/Onboarding/PromptEngineer/PersonasInPrompting",
            testWebhook: "https://auto.crm-s.com/webhook/Onboarding/PromptEngineering/Tests/PersonasInPrompting" 
          }
        ],
        2: [
          {
            title: "Iteration methods",
            contentWebhook: "https://auto.crm-s.com/webhook/Onboarding/PromptEngineer/IterationMethods",
            testWebhook: "https://auto.crm-s.com/webhook/Onboarding/PromptEngineering/Test/IterationMethods"
          },
          {
            title: "multimodal prompting",
            contentWebhook: "https://auto.crm-s.com/webhook/Onboarding/PromptEngineering/MultimodalPrompting",
            testWebhook: "https://hook.eu1.make.com/4yavh61809vwudjltlardrox3w98i7kj"
          },
          {
            title: "responsible AI Use",
            contentWebhook: "https://hook.eu1.make.com/ya6a12917mjqwfx9lhpxf9wy3now3f4r",
            testWebhook: "https://hook.eu1.make.com/cjn0iv6d6l6pdpzv9of1bpohnv419omj"
          }
        ]
      }
    };

    // Отдельный объект для словаря
    const vocabularyTopic = {
      title: "Prompt Engineering Vocabulary",
      contentWebhook: "https://auto.crm-s.com/webhook/PromptEngineering/Vocabulary",
      testWebhook: "placeholder-test-webhook-vocabulary"
    };

    // Функция для обработки изменения профессии
    function handleProfessionChange() {
      const selectedProfession = document.getElementById("profession-select").value;
      if (selectedProfession === "lead-generator") {
        window.location.href = "https://hook.eu1.make.com/jcjl176nvrhlm4ag7qiixjzssxqdbl5n";
      }
    }

    function selectDay(day) {
      window.currentDay = day;
      const selectedProfession = document.getElementById("profession-select").value;
      // Используем deep copy, чтобы не изменялись исходные данные
      currentTasks = JSON.parse(JSON.stringify(professionTasks[selectedProfession][day]));
      const dayHeader = document.getElementById("day-header");
      if (dayHeader) dayHeader.innerText = "Day " + day;
      const daySelection = document.getElementById("day-selection");
      if (daySelection) daySelection.classList.add("hidden");
      const taskSelection = document.getElementById("task-selection");
      if (taskSelection) taskSelection.classList.remove("hidden");
      const taskButtonsDiv = document.getElementById("task-buttons");
      if (taskButtonsDiv) {
        taskButtonsDiv.innerHTML = "";
        currentTasks.forEach((task, index) => {
          const btn = document.createElement("button");
          btn.innerText = task.title;
          btn.onclick = function() { selectTask(index); };
          taskButtonsDiv.appendChild(btn);
        });
      }
    }

    function goBackToDaySelection() {
      const taskSelection = document.getElementById("task-selection");
      if (taskSelection) taskSelection.classList.add("hidden");
      const daySelection = document.getElementById("day-selection");
      if (daySelection) daySelection.classList.remove("hidden");
    }

    // Функция возврата к списку топиков – обновляет его через selectDay с сохранённым днем и сбрасывает выбранный топик
    function goBackToTaskSelection() {
      hideAllAudio();
      const markdownDiv = document.getElementById("markdown-content");
      if (markdownDiv) markdownDiv.innerHTML = "";
      window.currentTopic = null;
      const home = document.getElementById("home");
      if (home) home.classList.remove("hidden");
      if (window.currentDay !== null) {
        selectDay(window.currentDay);
      }
      const guide = document.getElementById("guide");
      if (guide) guide.classList.add("hidden");
    }

    window.goBack = function() {
      showSection("home");
      const daySelection = document.getElementById("day-selection");
      if (daySelection) daySelection.classList.remove("hidden");
      const taskSelection = document.getElementById("task-selection");
      if (taskSelection) taskSelection.classList.add("hidden");
    };

    // Функция для открытия словаря
    function openVocabulary() {
      window.currentTopic = vocabularyTopic;
      const guideTitle = document.getElementById("guide-title");
      if (guideTitle) guideTitle.innerText = "Guide: " + window.currentTopic.title;
      hideAllAudio();
      // Аудио для Vocabulary остается скрытым
      // Скрываем кнопку теста для словаря
      document.getElementById("test-button").classList.add("hidden");
      showSection("guide");
      fetchMarkdownContent();
    }

    function selectTask(index) {
      window.currentTopic = currentTasks[index];
      const guideTitle = document.getElementById("guide-title");
      if (guideTitle) guideTitle.innerText = "Guide: " + window.currentTopic.title;
      hideAllAudio();
      // Показываем кнопку теста для обычных тем
      document.getElementById("test-button").classList.remove("hidden");
      showSection("guide");
      fetchMarkdownContent();
    }

    function hideAllAudio() {
      const audioIds = [
        "audio-first-lesson",
        "audio-vocabulary"
      ];
      audioIds.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.classList.add("hidden");
      });
    }

    function showSection(id) {
      const home = document.getElementById("home");
      if (home) home.classList.add("hidden");
      const guide = document.getElementById("guide");
      if (guide) guide.classList.add("hidden");
      const target = document.getElementById(id);
      if (target) target.classList.remove("hidden");
    }

    function fetchMarkdownContent() {
      const url = window.currentTopic.contentWebhook;
      const spinner = document.getElementById("loading-spinner");
      if (spinner) spinner.classList.remove("hidden");
      const markdownDiv = document.getElementById("markdown-content");
      if (markdownDiv) markdownDiv.classList.add("hidden");

      if (!url || url.startsWith("placeholder")) {
        if (spinner) spinner.classList.add("hidden");
        if (markdownDiv) {
          markdownDiv.classList.remove("hidden");
          markdownDiv.innerHTML = "<p>Placeholder content: Content will be added soon!</p>";
        }
        return;
      }

      // Больше не создаем options здесь, все параметры запроса определены внутри fetchContent

      // Enhanced fetch with better error handling, debugging and fallbacks
      const fetchContent = async (url, options) => {
        return new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          xhr.onload = () => {
            if (xhr.status >= 200 && xhr.status < 300) {
              resolve(xhr.response);
            } else {
              // Если основной запрос не удался, используем fallback fetch
              console.error("Main fetch failed:", xhr.status, xhr.statusText);
              const fetchOptions = {
                method: 'GET',
                headers: {
                  'Accept': 'text/plain, text/markdown, application/json, */*'
                },
                mode: 'cors',
                cache: 'no-cache',
                credentials: 'omit'
              };
              fetch(url, fetchOptions)
              .then(response => {
                if (!response.ok) {
                  const errorText = response.text().catch(e => "Unable to read response body");
                  throw new Error(`HTTP error! Status: ${response.status}, Status Text: ${response.statusText}, Response: ${errorText.substring(0, 500)}`);
                }
                return response.text();
              })
              .then(responseText => {
                resolve(responseText);
              })
              .catch(error => {
                // Если fallback fetch тоже не сработал, используем резервное содержимое
                console.error("Fetch failed:", error.message);
                useFallbackContent(url, reject, resolve);
              });
            };

            xhr.open('GET', url, true);
            // Пробуем получить текст
            xhr.responseType = 'text';
            xhr.send();
          };

          function useFallbackContent(url, reject, resolve) {
            // Предоставляем резервное содержимое на основе URL
            if (url.includes("IterationMethods")) {
              console.log("Using backup content for IterationMethods");
              resolve(getBackupContentForIterationMethods());
            } else if (url.includes("FiveStepFramework")) {
              console.log("Using backup content for FiveStepFramework");
              resolve(getBackupContentForFiveStepFramework());
            } else if (url.includes("PersonasInPrompting")) {
              console.log("Using backup content for PersonasInPrompting");
              resolve(getBackupContentForPersonasInPrompting());
            } else if (url.includes("WhatPromptingIs")) {
              console.log("Using backup content for WhatPromptingIs");
              resolve(getBackupContentForWhatPromptingIs());
            } else if (url.includes("Vocabulary")) {
              console.log("Using backup content for Vocabulary");
              resolve(getBackupContentForVocabulary());
            } else if (url.includes("MultimodalPrompting")) {
              console.log("Using backup content for MultimodalPrompting");
              resolve(`# Multimodal Prompting

Multimodal prompting is an advanced technique that involves providing inputs in multiple formats or modalities (such as text, images, audio, or video) to AI systems and receiving responses that may also span different modalities.

## What Makes Prompting Multimodal?

Traditional prompting primarily deals with text inputs and outputs. Multimodal prompting expands this to include:

- **Visual elements:** Images, diagrams, charts, or videos
- **Audio:** Speech, music, or sounds
- **Text:** Written instructions or queries

Multimodal AI models can process information across these different formats, analyzing the relationships between them and generating responses that may combine multiple modalities.

## Key Benefits

1. **Richer Communication:** Some concepts are better explained visually than textually (and vice versa)
2. **Expanded Capabilities:** Enables tasks that would be difficult or impossible with text alone
3. **Improved Accuracy:** Additional context from different modalities can lead to better understanding
4. **Natural Interaction:** Mimics how humans naturally communicate using multiple senses

## Common Use Cases

### Image Understanding and Generation

- **Image-to-text:** Describing images, extracting text from images, answering questions about visual content
- **Text-to-image:** Creating visuals based on textual descriptions
- **Image editing:** Modifying images based on text instructions

### Document Analysis

- Extracting information from documents that contain both text and visual elements
- Understanding the relationship between text, tables, charts, and other visual components

### Educational Content

- Creating explanations that combine text with diagrams or illustrations
- Generating visual aids to complement textual explanations

### Creative Applications

- Generating stories with accompanying images
- Creating marketing materials that combine compelling text with visuals

## Effective Multimodal Prompting Techniques

### Be Specific About Relationships

Clearly indicate how different modalities should relate to each other:
- "Explain how the graph supports or contradicts the text"
- "Create an image that illustrates the key points in this paragraph"

### Provide Context for Each Modality

When using images in prompts:
- "The image shows a manufacturing process diagram. Please explain each step labeled in the diagram."
- "This is a scientific chart showing experiment results. Interpret what it suggests about the hypothesis."

### Direct Attention

Guide the AI to focus on specific elements:
- "Focus on the object in the top-right corner of the image"
- "Pay special attention to how the chart data trends after 2020"

### Specify Output Format

Be clear about what form you want the response to take:
- "Generate a bullet-point list describing what's in the image"
- "Create a table comparing the elements visible in the provided images"

## Challenges and Limitations

### Misinterpretation

Multimodal systems may misunderstand relationships between different modalities or miss subtle visual cues.

### Quality Trade-offs

Current models may excel at one modality but provide lower quality in others.

### Increased Complexity

Multimodal prompts require more careful design and consideration than text-only prompts.

### Technical Constraints

File size limits, supported formats, and resolution requirements may restrict what can be included in prompts.

## Best Practices

1. **Start simple:** Begin with clearly defined tasks before moving to more complex multimodal interactions
2. **Iterate:** Test and refine prompts based on the responses received
3. **Provide examples:** When possible, show the AI an example of your desired output
4. **Consider context limitations:** Be aware that including images reduces the number of text tokens available
5. **Check accuracy:** Verify that the AI correctly understands relationships between different modalities

Multimodal prompting represents the cutting edge of AI interaction, opening up new possibilities for communication, creation, and problem-solving that better align with how humans naturally process information.`);
            } else {
              // Если резервное содержимое недоступно, генерируем базовый контент
              console.log("No specific backup content available, using generic fallback");
              resolve(`# ${window.currentTopic ? window.currentTopic.title : "Контент недоступен"}

Не удалось загрузить содержимое для данного урока. Возможные причины:

- Временная проблема с сервером
- Проблемы с сетевым подключением
- Проблемы с CORS (Cross-Origin Resource Sharing)

Пожалуйста, попробуйте позже или обратитесь к руководителю команды.`);
            }
          }
        });
      };

      fetchContent(url)
        .then(responseText => {
          console.log("Response received successfully!");
          console.log("Raw response:", responseText.substring(0, 200));

          // Always treat responses as plain text
          let markdown = responseText;

          // Only try to parse as JSON if it looks like JSON and we need to extract specific fields
          if (responseText.trim().startsWith('{') || responseText.trim().startsWith('[')) {
            try {
              const responseJson = JSON.parse(responseText);
              console.log("Response appears to be JSON format");

              // Extract markdown content from JSON if available
              if (responseJson.text) {
                console.log("Using 'text' field from JSON");
                markdown = responseJson.text;
              } else if (responseJson.content) {
                console.log("Using 'content' field from JSON");
                markdown = responseJson.content;
              } else if (responseJson.markdown) {
                console.log("Using 'markdown' field from JSON");
                markdown = responseJson.markdown;
              }
              // If no specific fields are found, keep the original text
            } catch (e) {
              console.log("Not valid JSON or JSON parsing error:", e.message);
              // Continue using the raw text
            }
          }

          if (!markdown.includes('#')) {
            markdown = "# " + window.currentTopic.title + "\n\n" + markdown;
          }

          const collapsibleHTML = createCollapsibleBlocks(markdown);
          if (markdownDiv) {
            markdownDiv.innerHTML = collapsibleHTML;
            spinner.classList.add("hidden");
            markdownDiv.classList.remove("hidden");
          }
        })
        .catch(error => {
          console.error("Loading error:", error);
          if (spinner) {
            spinner.classList.add("hidden");
          }
          if (markdownDiv) {
            markdownDiv.classList.remove("hidden");

            // Load emergency content for the Five-step Framework
            if (window.currentTopic && window.currentTopic.title === "Five-step Framework") {
              const fiveStepContent = `# Five-step Framework for Prompt Engineering

The Five-step Framework provides a structured approach to designing effective prompts for AI systems. Each step builds upon the previous one to create prompts that yield accurate, relevant, and useful responses.

## Step 1: Define the Goal

Before writing any prompt, clearly define what you want to achieve.

**Key Questions:**
- What specific output or information do you need?
- What format should the response take?
- Who is the end-user of this information?

**Example:**
Goal: "I need a comprehensive comparison of solar panel types for residential use that helps homeowners make an informed decision."

## Step 2: Provide Context

Give the AI relevant background information to ensure it understands the situation.

**Key Elements:**
- Relevant facts and data
- Audience information
- Domain-specific context
- Any constraints or requirements

**Example:**
"I'm creating content for middle-aged homeowners in sunny Arizona who are considering installing solar panels. They have limited technical knowledge but are environmentally conscious and budget-aware."

## Step 3: Specify Instructions

Clearly state what you want the AI to do and how it should do it.

**Key Components:**
- Task description
- Output format
- Tone and style guidance
- Length requirements

**Example:**
"Create a comparison table of the three most common residential solar panel types (monocrystalline, polycrystalline, and thin-film). Follow the table with 2-3 paragraphs explaining the key differences in layman's terms. Use a friendly but informative tone."

## Step 4: Use Constraints

Set boundaries to prevent unwanted content and guide the AI toward your desired outcome.

**Types of Constraints:**
- Content limitations
- Style restrictions
- Length parameters
- Ethical guardrails

**Example:**
"Avoid technical jargon without explanation. Don't include DIY installation instructions, as these systems require professional installation. Limit the response to 500 words."

## Step 5: Review and Refine

Analyze the AI's response and iterate on your prompt to improve results.

**Review Process:**
1. Evaluate the response against your goal
2. Identify missing or incorrect information
3. Note areas where instructions weren't followed
4. Adjust your prompt accordingly

**Example:**
"The information is good, but there's too much emphasis on cost and not enough on durability. Let me adjust my prompt to prioritize long-term value and performance in extreme weather conditions."

## Putting It All Together

A complete prompt using the Five-step Framework might look like:

"I need a comparison of residential solar panel types (Goal). This is for middle-aged homeowners in Arizona with limited technical knowledge but environmental awareness (Context). Create a table comparing monocrystalline, polycrystalline, and thin-film panels, followed by 2-3 explanatory paragraphs in layman's terms (Instructions). Avoid unexplained jargon and DIY installation details, and prioritize information on durability and performance in hot climates. Limit to 500 words (Constraints)."

By following this framework, you can systematically improve your prompts through each iteration, leading to increasingly accurate and useful AI responses.`;

              markdownDiv.innerHTML = createCollapsibleBlocks(fiveStepContent);
              return;
            }

            // Get detailed error information
            const errorStack = error.stack || '';
            const errorName = error.name || 'Error';
            const errorDetails = JSON.stringify(error, Object.getOwnPropertyNames(error), 2);

            markdownDiv.innerHTML = `
              <div style="background-color: #fff0f0; padding: 15px; border-left: 4px solid #ff0000; margin-bottom: 20px;">
                <h3>Ошибка загрузки контента</h3>
                <p>Пожалуйста, обратитесь к руководителю команды.</p>
                <p><strong>Причина:</strong> ${error.message || error.toString()}</p>
                <p><strong>Тип ошибки:</strong> ${errorName}</p>
                <p><strong>URL:</strong> ${url}</p>
                <details>
                  <summary><strong>Технические детали ошибки (для разработчиков)</strong></summary>
                  <pre style="background-color: #f8f8f8; padding: 10px; overflow: auto; max-height: 200px;">${errorDetails}</pre>
                </details>
                <p><small>Это может быть вызвано проблемами с CORS, сетевым подключением или недоступностью сервера.</small></p>
              </div>
            `;

            // Add console logging for debugging
            console.error("Detailed error information:", {
              message: error.message,
              name: errorName,
              url: url,
              details: errorDetails
            });
            console.error("Content loading error for URL:", url, error);

            // Check if we have a fallback for this content
            if (window.currentTopic) {
              const topicTitle = window.currentTopic.title;
              console.log("Looking for fallback content for:", topicTitle);

              // Display fallback content based on topic titles
              if (topicTitle === "Personas in prompting") {
                const personasContent = `# Personas in Prompting

## What are Personas?

Personas in prompt engineering refer to fictional characters or roles that you ask an AI to assume when responding to your prompt. By assigning a specific persona, you can guide the AI to leverage domain-specific knowledge, vocabulary, and reasoning approaches.

## Why Use Personas?

Using personas provides several key benefits:

### Expertise Access
By asking the AI to respond as an expert in a particular field, you can get more specialized information.

### Perspective Shifting
Different personas can provide varied viewpoints on the same question or problem.

### Tone Control
Personas help shape the style, formality, and tone of the AI's response.

### Problem-Solving Approaches
Different personas may use different methodologies to approach a problem.

## Types of Personas

### Expert Personas
These personas represent specialists in specific fields.

**Examples:**
- "As a quantum physicist..."
- "Respond as an experienced pediatrician..."
- "Taking the role of a cybersecurity expert..."

### Character Personas
These include fictional characters, historical figures, or archetypal roles.

**Examples:**
- "Explain this as if you were Sherlock Holmes..."
- "As a medieval blacksmith, describe..."
- "Channel the perspective of Leonardo da Vinci to..."

### Function-Based Personas
These personas focus on a specific task or function rather than expertise.

**Examples:**
- "Act as a summarizer..."
- "As a fact-checker, review..."
- "In the role of a debate moderator..."

## Best Practices

### Be Specific
Define the persona's characteristics clearly. Instead of just "as a scientist," try "as a marine biologist specializing in coral reef ecosystems."

### Provide Context
Give background information that helps the persona understand their role in responding.

### Add Constraints
Specify what the persona should or shouldn't focus on.

### Combine with Other Techniques
Personas work well when combined with other prompting techniques like Chain-of-Thought or Few-Shot examples.

## Examples

### Basic Persona Prompt
"As a financial advisor with 20 years of experience, explain the concept of dollar-cost averaging to a complete beginner."

### Advanced Persona Prompt
"You are a master chef at a Michelin-starred restaurant specializing in French cuisine. A home cook has asked you to help them elevate their basic omelet recipe. Provide specific techniques, ingredient suggestions, and plating ideas that would transform a simple omelet into a restaurant-quality dish. Consider both flavor combinations and presentation. Include at least one unexpected ingredient that works surprisingly well."

### Multi-Persona Analysis
"I need to understand the implications of implementing a four-day workweek in a medium-sized company. First, respond as a human resources director concerned with employee welfare. Then, respond as a CFO focused on financial impacts. Finally, respond as a productivity consultant looking at operational efficiency."

By mastering the use of personas in your prompts, you can access more specialized knowledge, get more creative responses, and approach problems from multiple perspectives.`;

                markdownDiv.innerHTML = createCollapsibleBlocks(personasContent);
                spinner.classList.add("hidden");
                markdownDiv.classList.remove("hidden");
                return;
              }
            }
          }

          // Just load some hardcoded text for specific topics
          if (window.currentTopic && window.currentTopic.title === "What prompting is") {
            const defaultContent = `# What prompting is

Prompting is a technique used to communicate with AI language models by providing them with specific instructions or input texts that guide their responses. It's the primary way humans interact with Large Language Models (LLMs) like ChatGPT, Claude, or Gemini.

## Why Prompts Matter

Effective prompts are crucial because they directly influence the quality and relevance of AI responses. The same AI model can generate dramatically different outputs based solely on how a prompt is phrased.

## Key Components of Prompts

### Instructions
Clear directions telling the AI what to do, how to respond, or what format to use.

### Context
Background information that helps the AI understand the topic or situation.

### Examples
Demonstrations of desired outputs that help the AI understand exactly what you want.

### Constraints
Limitations or boundaries that define what the AI should or shouldn't do.

## Different Types of Prompting

### Basic Prompting
Simple questions or statements that request information.
Example: "Explain what photosynthesis is."

### Role-Based Prompting
Asking the AI to assume a specific persona or role.
Example: ""As an expert botanist, explain what photosynthesis is."

### Few-Shot Prompting
Providing examples in the prompt to guide the AI's response format.
Example: "Q: What is the capital of France? A: Paris. Q: What is the capital of Japan? A:"

### Chain-of-Thought Prompting
Encouraging the AI to reason step-by-step through a problem.
Example: "Think step by step to solve this math problem: If x + y = 10 and x - y = 4, what are x and y?"

## Prompt Engineering

The practice of designing and refining prompts to get the best possible responses from AI is called prompt engineering. It has become a valuable skill as AI systems become more widespread.

Good prompt engineers understand:
- How different prompting techniques affect AI outputs
- Common pitfalls and how to avoid them
- How to iterate and refine prompts
- How to evaluate AI responses

## The Prompt Engineering Workflow

1. Define your goal clearly
2. Design an initial prompt
3. Evaluate the response
4. Refine the prompt based on the response
5. Repeat until satisfied with the result

The following lessons will explore these concepts in more detail and provide practical exercises to develop your prompt engineering skills.`;

            markdownDiv.innerHTML = createCollapsibleBlocks(defaultContent);
            if (spinner) spinner.classList.add("hidden");
            markdownDiv.classList.remove("hidden");
          } else if (window.currentTopic && window.currentTopic.title === "Prompt Engineering Vocabulary") {
            const vocabularyContent = `# Prompt Engineering Vocabulary

## Core Concepts

### Prompt
A text input given to an AI model that guides its response. This can include questions, instructions, examples, or constraints.

### Large Language Model (LLM)
An AI system trained on vast amounts of text data that can generate human-like text, understand context, and follow instructions.

### Prompt Engineering
The practice of designing and refining prompts to effectively communicate with AI models to get desired outputs.

### Token
The basic unit of text that LLMs process. A token can be a word, part of a word, or a character, depending on the model's tokenization method.

### Context Window
The maximum amount of text (measured in tokens) that an AI model can consider at once, including both the prompt and the generated response.

## Prompting Techniques

### Zero-shot Prompting
Asking an AI to perform a task without providing any examples.
Example: "Translate this sentence to French: 'Hello, how are you?'"

### Few-shot Prompting
Providing the AI with a few examples within the prompt to guide its response format or style.
Example: "English: Hello, French: Bonjour, English: Thank you, French: ?"

### Chain-of-Thought (CoT)
Prompting technique that encourages the AI to show its reasoning process step-by-step.
Example: "Think step by step to solve this math problem."

### Tree of Thoughts
An extension of Chain-of-Thought that explores multiple reasoning paths before arriving at a final answer.

### Role Prompting
Instructing the AI to assume a specific role or persona.
Example: "As an experienced chef, provide feedback on this recipe."

### Retrieval-Augmented Generation (RAG)
Combining an LLM with the ability to retrieve information from an external knowledge base during generation.

## Best Practices

### Specificity
Being clear and detailed in what you're asking the AI to do.

### Structured Format
Organizing prompts with clear sections like "Context," "Instructions," and "Format."

### Constraints
Setting boundaries on what the AI should or shouldn't include in its response.

### Iteration
The process of refining prompts based on the AI's responses to improve results over time.

## Common Challenges

### Prompt Injection
A security concern where malicious instructions are hidden within benign-looking prompts to manipulate the AI's behavior.

### Hallucination
When an AI confidently generates incorrect information that wasn't in its training data.

### Model Alignment
The degree to which an AI's outputs match human values, intentions, and expectations.

### Context Truncation
When a prompt is too long and exceeds the model's context window, causing information loss.`;

            markdownDiv.innerHTML = createCollapsibleBlocks(vocabularyContent);
            if (spinner) spinner.classList.add("hidden");
            markdownDiv.classList.remove("hidden");
          }
        });
    }

    function createCollapsibleBlocks(markdown) {
      markdown = markdown.trim();

      const lines = markdown.split("\n");
      let htmlOutput = "";
      let currentLevel1Title = "";
      let currentLevel1Content = [];
      let inLevel1 = false;

      if (lines.length > 0 && !lines[0].match(/^#\s+/)) {
        lines.unshift("# " + (window.currentTopic ? window.currentTopic.title : "Content"));
      }

      for (let line of lines) {
        let match = line.match(/^#(?!#)\s*(.+)/);
        if (match) {
          if (inLevel1) {
            htmlOutput += renderLevel1Block(currentLevel1Title, currentLevel1Content.join("\n"));
          }
          currentLevel1Title = match[1].trim();
          currentLevel1Content = [];
          inLevel1 = true;
        } else {
          if (inLevel1) {
            currentLevel1Content.push(line);
          }
        }
      }
      if (inLevel1) {
        htmlOutput += renderLevel1Block(currentLevel1Title, currentLevel1Content.join("\n"));
      } else if (!htmlOutput) {
        htmlOutput = marked.parse(markdown);
      }
      return htmlOutput;
    }

    function renderLevel1Block(title, content) {
      const lines = content.split("\n");
      let html = "";
      let subBlocksHtml = "";
      let currentSubTitle = "";
      let currentSubContent = [];
      let hasSubHeader = false;
      let preambleLines = [];

      for (let line of lines) {
        let subMatch = line.match(/^##(?!#)\s*(.+)/);
        if (subMatch) {
          hasSubHeader = true;
          if (currentSubTitle) {
            subBlocksHtml += renderLevel2Block(currentSubTitle, currentSubContent.join("\n"));
            currentSubContent = [];
          }
          currentSubTitle = subMatch[1].trim();
        } else {
          if (hasSubHeader) {
            currentSubContent.push(line);
          } else {
            preambleLines.push(line);
          }
        }
      }
      if (currentSubTitle) {
        subBlocksHtml += renderLevel2Block(currentSubTitle, currentSubContent.join("\n"));
      }
      if (preambleLines.length) {
        html += marked.parse(preambleLines.join("\n"));
      }
      html += subBlocksHtml;
      return `<details>
  <summary>${title}</summary>
  <div>${html}</div>
</details>`;
    }

    function renderLevel2Block(title, content) {
      const lines = content.split("\n");
      let html = "";
      let subBlocksHtml = "";
      let currentSubTitle = "";
      let currentSubContent = [];
      let hasSubHeader = false;
      let preambleLines = [];

      for (let line of lines) {
        let subMatch = line.match(/^###(?!#)\s*(.+)/);
        if (subMatch) {
          hasSubHeader = true;
          if (currentSubTitle) {
            subBlocksHtml += renderLevel3Block(currentSubTitle, currentSubContent.join("\n"));
            currentSubContent = [];
          }
          currentSubTitle = subMatch[1].trim();
        } else {
          if (hasSubHeader) {
            currentSubContent.push(line);
          } else {
            preambleLines.push(line);
          }
        }
      }
      if (currentSubTitle) {
        subBlocksHtml += renderLevel3Block(currentSubTitle, currentSubContent.join("\n"));
      }
      if (preambleLines.length) {
        html += marked.parse(preambleLines.join("\n"));
      }
      html += subBlocksHtml;
      return `<details style="margin-left:20px;">
  <summary>${title}</summary>
  <div>${html}</div>
</details>`;
    }

    function renderLevel3Block(title, content) {
      let parsedContent = marked.parse(content);
      return `<details style="margin-left:40px;">
  <summary>${title}</summary>
  <div>${parsedContent}</div>
</details>`;
    }
  </script>
</body>
</html>